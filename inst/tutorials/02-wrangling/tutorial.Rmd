---
title: "Wrangling"
output:
  learnr::tutorial:
      progressive: true
      allow_skip: true
runtime: shiny_prerendered
description: "Chapter 2 tutorial"
---

<!-- Things to fix in this tutorial. -->

<!-- It is a bad idea to create a column called "type" since that is the name of an R function. -->

<!-- Don't use a random package like fueleconomy. We need to minimize the number of extra packages we use.  -->
<!-- Be careful about manipulating an object in place for no good reason. Example:  -->

<!-- lexus_1998 <- lexus_1998 %>% -->
<!--   rename("class" = type) -->

<!-- Even if you need a special object called lexus_1998, just create once. Key -->


```{r setup, include=FALSE}
library(tidyverse)
library(learnr)
library(shiny)
library(PPBDS.data)
knitr::opts_chunk$set(echo = FALSE, message = FALSE)
options(tutorial.exercise.timelimit = 60)  

# Set up stringr-objects
library(dslabs)
murders <- as_tibble(murders)
states <- murders$state
states2 <- murders %>%
  select(state, abb)

# Set up cars
# DK: Creating a column called "type" is a bad idea since it is an R function
# name. Also, why are we using this random R package?

library(fueleconomy)
lexus_2000 <- vehicles %>%
  filter(year == 2000,
         make == "Lexus") %>%
  select(id, make, model, class, drive)

lexus_1999 <- vehicles %>%
  filter(year == 1999,
         make == "Lexus") %>%
  select(id, make, model, class, trans, drive) 

lexus_1998 <- vehicles %>%
  filter(year == 1998,
         make == "Lexus") %>%
  select(id, make, model, class, trans, drive) %>%
  rename("type" = class)

lexus_mileage <- vehicles %>%
  filter(year == 2000,
         make == "Lexus") %>%
  select(id, hwy, cty) %>%
  slice(3:9)

# Needed for later sections of the tutorial 
library(fivethirtyeight)
library(ggthemes)
```

## Introduction 

``` {r name, echo=FALSE}
question_text(
  "Student Name:",
  answer(NULL, correct = TRUE),
  incorrect = "Ok",
  try_again_button = "Modify your answer",
  allow_retry = TRUE
)
```

## Characters 
Use `str_detect()` on `states` to find state that contain the pattern "ana":
```{r exercise-2-1, exercise=TRUE}

```

```{r exercise-2-1-hint, eval=FALSE}
str_detect(..., pattern = ...)
```

Now use `str_subset()` with `states` to find the names of the states that contain the pattern "ana" instead of just the boolean values: 
```{r exercise-2-2, exercise=TRUE}

```

```{r exercise-2-2-hint, eval=FALSE}
str_subset(..., pattern = ...)
```

Use `str_subset()` to find `states` that have two a's in their name:
```{r exercise-2-3, exercise=TRUE}

```

```{r exercise-2-3-hint-1, eval=FALSE}
# Considering use the regex "."
```

```{r exercise-2-3-hint-2, eval=FALSE}
str_subset(..., pattern = ...)
```

`str_split()` `states` that are two or more words:
```{r exercise-2-4, exercise=TRUE}

```

```{r exercise-2-4-hint, eval=FALSE}
str_split(..., pattern = ...)
```

`str_split_fixed()` `states` into two words. What will happen to `District of Columbia`?
```{r exercise-2-5, exercise=TRUE}

```

```{r exercise-2-5-hint, eval=FALSE}
str_split_fixed(..., pattern = ..., n = ...)
```

Collapse `states` using `str_c()`, and separate them with a comma.
```{r exercise-2-6, exercise=TRUE}

```

```{r exercise-2-6-hint, eval=FALSE}
str_c(states, collapse = ",")
```

Use `str_c` to collapse states into the form `state1 & state2`. Combine the first 1-25 states with states 26-50. Note that we have to exclude the 51st state.
```{r exercise-2-7, exercise=TRUE}

```

```{r exercise-2-7-hint, eval=FALSE}
str_c(..., ..., sep = ...)
```

Use `str_replace()` to replace the pattern `North` with `N.`. For example, transform North Carolina into N. Carolina.
```{r exercise-2-8, exercise=TRUE}

```

```{r exercise-2-8-hint, eval=FALSE}
str_replace(..., pattern = ..., replacement = ...)
```

Use `str_subset()` to find `states` that contain the letter a and then one or more characters and another a.
```{r exercise-2-9, exercise=TRUE}

```

```{r exercise-2-9-hint-1, eval=FALSE}
# Consider using the pattern "a.*a"
```

```{r exercise-2-9-hint-2, eval=FALSE}
str_subset(..., pattern = ...)
```

Does capitalization matter? Repeat the previous question but replace the first letter with a capital "A". 
```{r exercise-2-10, exercise=TRUE}

```

```{r exercise-2-10-hint, eval=FALSE}
str_subset(..., pattern = ...)
```

`glimpse()` the `states2` tibble. 
```{r exercise-2-11, exercise=TRUE}

```

```{r exercise-2-11-hint, eval=FALSE}
glimpse(states2)
```

`mutate()` the `states2` dataset so that it contains a column `state_length` that takes the `str_length()` of each `state`. Then, `arrange()` the dataset from the state with the longest name to that with the shortest.
```{r exercise-2-12, exercise=TRUE}

```

```{r exercise-2-12-hint, eval=FALSE}
states2 %>% 
  mutate(... = str_length(...)) %>%
  arrange(desc(...))
```

Now compare the previous question by the `states2` dataset arranged by `desc(state)`. How does this arrangement differ from the previous one?
```{r exercise-2-13, exercise=TRUE}

```

```{r exercise-2-13-hint, eval=FALSE}
... %>% 
  arrange(desc(...))
```

`mutate()` the `state` column of `states2` to only contain the first two letters of each state name. Reassign this as `states2`.
```{r exercise-2-14, exercise=TRUE}

```

```{r exercise-2-14-hint-1, eval=FALSE}
... <- states2 %>% mutate(... = str_sub(...))
```

```{r exercise-2-15-setup}
states2 <- states2 %>%
  mutate(state = str_sub(state, 1, 2))
```

Now use `str_to_upper()` and `mutate()` to make both of the first two letters of the states capital letters. Reassign this as `states2`.
```{r exercise-2-15, exercise=TRUE}

```

```{r exercise-2-15-hint, eval=FALSE}
... <- states2 %>% mutate(... = str_to_upper(...))
```

```{r exercise-2-16-setup}
states2 <- states2 %>% 
  mutate(state = str_sub(state, 1, 2)) %>% 
  mutate(state = str_to_upper(state))
```

`mutate()` a new column called `match` that creates a TRUE or FALSE value if the first two letters of the state name (the `state` column) and the `abb` column match.
```{r exercise-2-16, exercise=TRUE}

```

```{r exercise-2-16-hint, eval=FALSE}
states2 %>% mutate(match = (... == ...))
```

```{r exercise-2-17-setup}
states2 <- states2 %>%
  mutate(state = str_sub(state, 1, 2)) %>% 
  mutate(state = str_to_upper(state)) %>%
  mutate(match = (state == abb))
```
`count()` the `match` column.
```{r exercise-2-17, exercise=TRUE}

```

```{r exercise-2-17-hint, eval=FALSE}
states2 %>% count(...)
```

```{r exercise-2-17-quiz}
quiz(
  question("How many state abbreviations match the first two letters of the state's name?",
    answer("15"),
    answer("42"),
    answer("23"),
    answer("32", correct = TRUE),
    allow_retry = TRUE
  )
)
```

## Factors 

## Lists

## Date-Times 

## Combining Data

### bind_rows()
### Exercise 1

Run `lexus_2000` in this code chunk:
```{r exercise-combining-1, exercise=TRUE}

```

```{r exercise-combining-1-hint, eval=FALSE}
lexus_2000
```

### Exercise 2
Run `lexus_1999` in the code chunk: 
```{r exercise-combining-2, exercise=TRUE}

```

```{r exercise-combining-2-hint, eval=FALSE}
lexus_1999
```

```{r quiz-combining-2}
quiz(
  question("Which variable is included in lexus_1999 but not lexus_2000",
    answer("id"),
    answer("make"),
    answer("model"),
    answer("class"),
    answer("trans", correct = TRUE),
    answer("drive"),
    allow_retry = TRUE
  )
)
```
What do you think will happen we try to bind the rows? 

### Exercise 3

Use `bind_rows()` to bind `lexus_1999` and `lexus_2000`:
What happens to the `trans` column?
```{r question-combining-3, exercise=TRUE}

```

```{r question-combining-3-hint, eval=FALSE}
bind_rows(..., ...)
```

### Exercise 4 

Run `lexus_1998` in the following code chunk:
```{r question-combining-4, exercise=TRUE}

```
What is the discrepancy between the columns of `lexus_1998` and `lexus_1999`. How do you think this will affect binding the rows of the two dataframes?

### Exercise 5

Bind the two dataframes `lexus_1998` and `lexus_1999`:
```{r question-combining-5, exercise=TRUE}
bind_rows(lexus_1998, lexus_1999)
```

```{r question-combining-5-hint, eval=FALSE}
bind_rows(..., ...)
```

### Exercise 6

Use the `rename()` function to change the `type` variable to `class` in the `lexus_1998` dataframe. Use the assignment operator to reassign the changed dataframe to `lexus_1998`. 
```{r question-combining-6, exercise=TRUE}

```

```{r question-combining-6-hint, eval=FALSE}
... <- ... %>%
  rename(...)
```

### Exercise 7

Use `bind_rows` to bind `lexus_1998` and `lexus_1999` again. Assign this dataframe as `lexus_two_year`: 
```{r question-combining-7, exercise=TRUE}

```

```{r question-combining-7-hint, eval=FALSE}
... <- bind_rows(..., ...)
```

### Exercise 8

```{r question-combining-8-setup}
lexus_1998 <- lexus_1998 %>%
  rename("class" = type)
lexus_two_year <- bind_rows(lexus_1998, lexus_1999)
```
Now bind the rows of `lexus_two_year` with `lexus_2000`. Use the assignment operator to call this dataframe `lexus`
```{r question-combining-8, exercise=TRUE}

```

```{r question-combining-8-hint, eval=FALSE}
... <- bind_rows(..., ...)
```

### Exercise 9

```{r question-combining-9-setup}
lexus_two_year <- bind_rows(lexus_1998, lexus_1999)
lexus <- bind_rows(lexus_two_year, lexus_2000)
```

Now, `unite()` the `make` and `model` columns of the `lexus` dataframe. Name this united column `vehicle`, and make the separator between the previous columns a space.
```{r question-combining-1, exercise=TRUE}

```

```{r question-combining-9-hint-1, eval=FALSE}
lexus %>%
  unite(..., ..., ..., sep = ...)
```

```{r question-combining-9-hint-2, eval=FALSE}
lexus %>%
  unite("vehicle", ..., ..., sep = " ")
```

### joins in dplyr

### Exercise 10 

Let's return to the `lexus_2000` data. `glimpse()` both the `lexus_2000` dataframe and the `lexus_mileage` dataframe.
```{r question-combining-10, exercise=TRUE}

```

```{r question-combining-10-hint, eval=FALSE}
glimpse(... )

glimpse(...)
```

### Exercise 11

Now use the extraction operator `$` on the `id` columns of both `lexus_2000` and `lexus_mileage`.
```{r question-combining-11, exercise=TRUE}

```

```{r question-combining-11-hint, eval=FALSE}
lexus_2000$...

lexus_mileage$...
```

```{r question-combining-11-quiz}
quiz(
  question("Which id(s) are included in the lexus_2000 dataframe but not in the lexus_mileage dataframe?",
    answer("16365, 16366"),
    answer("15921, 15922, 16038, 16366, 16039, 15685, 15686"),
    answer("15801"),
    answer("15920, 15801", correct = TRUE),
    answer("15801, 15920, 15921"),
    answer("15685, 16039"),
    allow_retry = TRUE
  )
)
```

### Exercise 12
```{r question-combining-12-quiz}
quiz(
  question("Which id(s) will be excluded when you full_join() both datasets?",
    answer("None", correct = TRUE),
    answer("16365, 16366"),
    answer("15920, 15801"),
    answer("15801, 15922"),
    allow_retry = TRUE
  )
)
```

`full_join()` the `lexus_2000` and `lexus_mileage` dataframes by the `id` columns. Visually confirm your answer to the question above.
```{r question-combining-12, exercise=TRUE}

```

```{r question-combining-12-hint, eval=FALSE}
full_join(..., ..., by = ...)
```

### Exercise 13 
```{r question-combining-13-quiz}
quiz(
  question("Which id(s) will be excluded when you inner_join() both datasets?",
    answer("None"),
    answer("16365, 16366"),
    answer("15920, 15801", correct = TRUE),
    answer("15801, 15922"),
    allow_retry = TRUE
  )
)
```
`inner_join()` the `lexus_2000` and `lexus_mileage` dataframes by the `id` columns. Visually confirm your answer to the question above.
```{r question-combining-13, exercise=TRUE}

```

```{r question-combining-13-hint, eval=FALSE}
inner_join(..., ..., by = ...)
```

### Exercise 14
```{r question-combining-14-1-quiz}
quiz(
  question("Which id(s) will be excluded when you run left_join(lexus_2000, lexus_mileage, by = 'id')?",
    answer("None", correct = TRUE),
    answer("All"),
    answer("15920, 15801"),
    answer("15801, 15922"),
    allow_retry = TRUE
  )
)

```

```{r question-combining-14-2-quiz}
quiz(
  question("Which id(s) will be excluded when you run left_join(lexus_mileage, lexus_2000)?",
    answer("None"),
    answer("All"),
    answer("15920, 15801", correct = TRUE),
    answer("15801, 15922"),
    allow_retry = TRUE
  )
)
```

```{r question-combining-14-3-quiz}
quiz(
  question("Which id(s) will be excluded when you run left_join(lexus_mileage, lexus_2000, by = 'id')?",
    answer("None"),
    answer("All"),
    answer("15920, 15801", correct = TRUE),
    answer("15801, 15922"),
    allow_retry = TRUE
  )
)
```

```{r question-combining-14-4-quiz}
quiz(
  question("Which id(s) will be excluded when you run right_join(lexus_2000, lexus_mileage, by = 'id')?",
    answer("None"),
    answer("All"),
    answer("15920, 15801", correct = TRUE),
    answer("15801, 15922"),
    allow_retry = TRUE
  )
)
```

```{r question-combining-14-5-quiz}
quiz(
  question("Which id(s) will be excluded when you run right_join(lexus_mileage, lexus_2000, by = 'id')?",
    answer("None", correct = TRUE),
    answer("All"),
    answer("15920, 15801"),
    answer("15801, 15922"),
    allow_retry = TRUE
  )
)
```

```{r question-combining-14-6-quiz}
quiz(
  question("Which id(s) will be excluded when you run anti_join(lexus_mileage, lexus_2000, by = 'id')?",
    answer("None"),
    answer("All", correct = TRUE),
    answer("15920, 15801"),
    answer("15801, 15922"),
    allow_retry = TRUE
  )
)
```

```{r question-combining-14-7-quiz}
quiz(
  question("Which id(s) will be excluded when you run anti_join(lexus_2000, lexus_mileage, by = 'id')?",
    answer("None"),
    answer("All"),
    answer("15920, 15801", correct = TRUE),
    answer("15801, 15922"),
    allow_retry = TRUE
  )
)
```

```{r question-combining-14-8-quiz}
quiz(
  question("Which columns will be excluded when you run semi_join(lexus_2000, lexus_mileage, by = 'id')?",
    answer("id, hwy, cty"),
    answer("hwy, cty", correct = TRUE),
    answer("id, class, drive"),
    answer("id, make, model, class, drive"),
    allow_retry = TRUE
  )
)
```

```{r question-combining-14-9-quiz}
quiz(
  question("Which columns will be excluded when you run semi_join(lexus_mileage, lexus_2000, by = 'id')?",
    answer("id, hwy, cty"),
    answer("hwy, cty"),
    answer("id, class, drive"),
    answer("make, model, class, drive", correct = TRUE),
    allow_retry = TRUE
  )
)
```

## Tidying Data

### Exercise 1
Run `table1` in the code chunk below:
```{r question-tidying-1, exercise=TRUE}

```

```{r question-tidying-1-solution}
table1
```

```{r question-tidying-1-quiz}
quiz(
  question("Is table1 in tidy format?",
  answer("Yes", correct = TRUE),
  answer("No"),
  allow_retry = TRUE
)
)

```

### Exercise 2
Now, run `table2` in the code chunk below:
```{r question-tidying-2, exercise=TRUE}

```

```{r question-tidying-2-solution}
table2
```

```{r question-tidying-2-quiz}
quiz(
  question("Is table2 in tidy format?",
  answer("Yes"),
  answer("No", correct = TRUE),
  allow_retry = TRUE
)
)
```

### Exercise 3 
Use `pivot_longer()` to put `table1` into untidy format.
```{r question-tidying-3, exercise=TRUE}

```

```{r question-tidying-3-hint, eval=FALSE}
... %>%
  pivot_longer(cols = ..., names_to = ..., values_to = ...)
```

### Exercise 4 

Use `pivot_wider()` to put `table2` into tidy format.
```{r question-tidying-4, exercise=TRUE}

```

```{r question-tidying-4-hint, eval=FALSE}
... %>%
  pivot_wider(names_from = ..., values_from = ...)
```

## Data Wrangling: nhanes

`nhanes` is a dataset included in the Five Thirty Eight data package. This dataset was referenced in Five Thirty Eight's article ["Don't Take Your] Vitamins" (https://fivethirtyeight.com/features/dont-take-your-vitamins/) and was take from the "National Health and Nutrition Examination Survey," which contains the personal and physical information of 10,000 Americans from two surveys in 2009 and 2011.

### Exercise 1
Begin by running `summary()` on `nhanes`. Based on the results, try to guess what the units of measurement are for the `weight` and `height` variables.

```{r nhanes1, exercise = TRUE}

```

### Exercise 2

In the original tibble, `weight` is measured in kg and `height` in cm. Using `mutate()`, multiply `weight` by 2.2 and divide `height` by 30.48 to convert units into pounds and feet. Use this assignment operator to name this mutated tibble `nhanes_imperial`. 

```{r nhanes2, exercise = TRUE}

```

```{r nhanes2-hint, eval = FALSE}
nhanes_imperial <- nhanes %>%
  mutate(weight = ..., height = ...)
```

### Exercise 3

`select()` the `gender`, `weight`, `height`, and `bmi` columns from the `nhanes_imperial` tibble. Reassign this as `nhanes_imperial`. 

```{r nhanes3-setup}
nhanes_imperial <- nhanes %>%
  mutate(weight = weight * 2.2, height = height / 30.48)

```

```{r nhanes3, exercise = TRUE}

```

```{r nhanes3-hint}
nhanes_imperial <- nhanes_imperial %>%
  select(..., ..., ..., ...)
```

### Exercise 4

Use tidyr's `drop_na()` to remove all rows with a value of `NA` in either the `weight` or `height` columns. Reassign this as `nhanes_imperial`, so it will be saved. 

```{r nhanes4-setup}
nhanes_imperial <- nhanes %>%
  mutate(weight = weight * 2.2, height = height / 30.48) %>%
  select(gender, weight, height, bmi)
```

```{r nhanes4, exercise = TRUE, exercise.lines = 4}

```

```{r nhanes4-hint, eval = FALSE}
nhanes_imperial <- nhanes_imperial %>%
  drop_na(..., ...)
```

### Exercise 5

Call `ggplot()` to make a jittered scatterplot that maps `weight` to the x-axis, `height` to the y-axis, and `bmi` to the color aesthetic. Names this plot `nhanes_plot`. 

```{r nhanes5-setup}
nhanes_imperial <- nhanes %>%
  mutate(weight = weight * 2.2, height = height / 30.48) %>%
  select(gender, weight, height, bmi) %>%
  drop_na(weight, height)
```

```{r nhanes5, exercise = TRUE}

```

```{r nhanes5-hint-1}
# Remember to use geom_jitter().
```

```{r nhanes5-hint-2}
nhanes_plot <- ggplot(data = ..., aes(x = ..., y = ..., color = ...))
```

### Exercise 6

Add a trend line layer to your plot with `geom_smooth()`. Change the `se` argument of `geom_smooth()` to remove the confidence interval, and change the `color` of the line to "dodgerblue." Be sure to reassign this changed plot to the object name `nhanes_plot`. 

```{r nhanes6-setup}
nhanes_imperial <- nhanes %>%
  mutate(weight = weight * 2.2, height = height / 30.48) %>%
  select(gender, weight, height, bmi) %>%
  drop_na(weight, height) 
nhanes_plot <- ggplot(data = nhanes_imperial, 
                      mapping = aes(x = weight, y = height, color = bmi)) +
    geom_jitter()
```

```{r nhanes6, exercise = TRUE}

```

```{r nhanes6-hint-1}
# The se argument should be equal to FALSE.
```

```{r nhanes6-hint-2}
nhanes_plot <- nhanes_plot + 
  geom_smooth(se = ..., color = ...)
```

### Exercise 7

Use `facet_wrap()` to facet the `nhanes_plot` graph by `gender`.

```{r nhanes7-setup}
nhanes_imperial <- nhanes %>%
  mutate(weight = weight * 2.2, height = height / 30.48) %>%
  select(gender, weight, height, bmi) %>%
  drop_na(weight, height) 
nhanes_plot <- ggplot(data = nhanes_imperial, 
                      mapping = aes(x = weight, y = height, color = bmi)) +
    geom_jitter() +
    geom_smooth(se = FALSE, color = "dodgerblue")
```

```{r nhanes7, exercise = TRUE}

```

```{r nhanes7-hint}
nhanes_plot <- nhanes_plot +
  facet_wrap(...)
```


### Exercise 8

Finally, adjust the feel of the graph with `theme_clean()` from the **ggthemes** package. Make sure you have this package loaded, or you will be unable to run the code chunk. 

```{r nhanes8-setup}
nhanes_imperial <- nhanes %>%
  mutate(weight = weight * 2.2, height = height / 30.48) %>%
  select(gender, weight, height, bmi) %>%
  drop_na(weight, height) 

nhanes_plot <- ggplot(data = nhanes_imperial, 
                      mapping = aes(x = weight, y = height, color = bmi)) +
    geom_jitter() +
    geom_smooth(se = FALSE, color = "dodgerblue") +
    facet_wrap(~ gender)
```

```{r nhanes8, exercise = TRUE}

```

```{r nhanes8-hint}
nhanes_plot <- nhanes_plot +
  ...
```

### Exercise 9

Great work! From this graph, we can see that children of both genders tend to grow very quickly without gaining much weight (this is the very steep slope at the beginning of the two graphs). However, after people reach between 100-120 pounds, weight gain becomes coupled with a substantially smaller increase in height. Additionally, both weight and height seem to be higher for males than for females on average. Finally, we can infer from looking at the color gradient that a high `bmi` (i.e. brighter colors) corresponds with higher weight and lower height.

To finish your plot, use `labs()` to give the graph a title and subtitle of your choice.

```{r nhanes9-setup}
nhanes_imperial <- nhanes %>%
  mutate(weight = weight * 2.2, height = height / 30.48) %>%
  select(gender, weight, height, bmi) %>%
  drop_na(weight, height)

nhanes_plot <- ggplot(data = nhanes_imperial, 
                      mapping = aes(x = weight, y = height, color = bmi)) +
  geom_jitter() +
  geom_smooth(se = FALSE, color = "dodgerblue") +
  facet_wrap(~ gender) + 
  theme_clean()
```

```{r nhanes9, exercise = TRUE}

```

```{r nhanes9-hint, eval = FALSE}
nhanes_plot +
  labs(title = ..., subtitle = ...)
```

## Data Wrangling: kenya

The `kenya` data set (from the `PPBDS.data` package) records the data from a study in which poll stations in Kenya were assigned to either the control group or a group in which one or more methods were used to encourage voter registration (an SMS reminder, canvassing, etc.)

### Exercise 1

Start by `glimpse()`ing the `kenya` data set.

```{r kenya1-setup}
PPBDS.data::kenya
```

```{r kenya1, exercise = TRUE}

```

```{r kenya1-hint}
glimpse(kenya)
```

### Exercise 2

Pipe `kenya` into the `count()` function to count the number of poll stations in each `treatment` group.

```{r kenya2-setup}
PPBDS.data::kenya
```

```{r kenya2, exercise = TRUE}

```

```{r kenya2-hint, eval = FALSE}
kenya %>%
  count(...)
```

### Exercise 3

Using a pipe and the `%in%` operator, `filter()` `kenya` to only the rows with a `treatment` of "control," "local," "SMS," or "canvass." Assign this new dataframe to `kenya_subset`.

```{r kenya3-setup}
PPBDS.data::kenya
```

```{r kenya3, exercise = TRUE}

```

```{r kenya3-hint-1}
... <- kenya %>%
  filter(treatment %in% ...)
```

```{r kenya3-hint-2}
kenya_subset <- kenya %>%
  filter(treatment %in% c(...))
```

### Exercise 4

Because `treatment` is a factor, call `droplevels()` immediately after the `filter()` call to avoid future complications. Reassign this as `kenya_subset`. 

```{r kenya4-setup}
kenya_subset <- kenya %>% 
  filter(treatment %in% c("control", "local", "SMS", "canvass"))
```

```{r kenya4, exercise = TRUE}

```

```{r kenya4-hint}
kenya_subset <- kenya_subest %>%
  ...
```

### Exercise 5 

`select()` the `treatment`, `mean_age`, and `reg_byrv13` columns in `kenya_subset`. Don't forget to re-save this as `kenya_subset`. 

```{r kenya5-setup}
kenya_subset <- kenya %>%
  filter(treatment %in% c("control", "local", "SMS", "canvass")) %>%
  droplevels()
```

```{r kenya5, exercise = TRUE}

```

```{r kenya5-hint}
kenya_subset <- kenya_subset %>%
  select(...)
```

### Exercise 6

Use tidyr's `drop_na()` to remove all rows with a value of `NA` in the `mean_age` column. Reassign this as `kenya_subset`. 

```{r kenya6-setup}
kenya_subset <- kenya %>%
  filter(treatment %in% c("control", "local", "SMS", "canvass")) %>%
  droplevels() %>%
  select(treatment, mean_age, reg_byrv13)
```

```{r kenya6, exercise = TRUE}

```

```{r kenya6-hint, eval = FALSE}
kenya_subset <- kenya_subset %>%
  drop_na(...)
```

### Exercise 7

The dplyr `ntile()` function divides a continuous numerical value into categories depending on its size. Try running the following code to see how we can categorize the polling stations into 4 equally-sized groups based on the `distance` to the polling station.

```{r kenya7-setup}
PPBDS.data::kenya
```

```{r kenya7, exercise = TRUE}
kenya %>%
  mutate(distance_quartile = ntile(distance, 4))
```

### Exercise 8 

Use `mutate()` and `ntile()` to create the variable `age_half`, which categorizes the `mean_age` variable into 2 groups: the younger half, and the older half.

```{r kenya8-setup}
kenya_subset <- kenya %>%
  filter(treatment %in% c("control", "local", "SMS", "canvass")) %>%
  droplevels() %>%
  select(treatment, mean_age, reg_byrv13) %>%
  drop_na(mean_age)
```

```{r kenya8, exercise = TRUE}

```

```{r kenya8-hint}
# ntile(mean_age, 2) will categorize age into the younger half and the older half.
```

### Exercise 9

Group the data by `treatment` and `age_half`.

```{r kenya9-setup}
kenya_subset <- kenya %>%
  filter(treatment %in% c("control", "local", "SMS", "canvass")) %>%
  droplevels() %>%
  select(treatment, mean_age, reg_byrv13) %>%
  drop_na(mean_age) %>%
  mutate(age_half = ntile(mean_age, 2))
```

```{r kenya9, exercise = TRUE}

```

```{r kenya9-hint}
kenya_subset <- kenya_subset %>%
  group_by(...)
```

### Exercise 10

Using `summarize()`, calculate the variable `mean_turnout` as the average value of `reg_byrv13` in each group. Remember to set the `na.rm` argument of `mean()` to `TRUE`, as there are some `NA` values in the `reg_byrv13` column.

```{r kenya10-setup}
kenya_subset <- kenya %>%
  filter(treatment %in% c("control", "local", "SMS", "canvass")) %>%
  droplevels() %>%
  select(treatment, mean_age, reg_byrv13) %>%
  drop_na(mean_age) %>%
  mutate(age_half = ntile(mean_age, 2)) %>%
  group_by(treatment, age_half)
```

```{r kenya10, exercise = TRUE}

```

```{r kenya10-hint, eval = FALSE}
kenya_subset <- kenya_subset %>%
  summarize(mean_turnout = ...)
```

### Exercise 11 

Create a `ggplot()` named `kenya_plot` that makes a bar graph with `treatment` on the x-axis and `mean_turnout` on the y-axis.

```{r kenya11-setup}
kenya_subset <- kenya %>%
  filter(treatment %in% c("control", "local", "SMS", "canvass")) %>%
  droplevels() %>%
  select(treatment, mean_age, reg_byrv13) %>%
  drop_na(mean_age) %>%
  mutate(age_half = ntile(mean_age, 2)) %>%
  group_by(treatment, age_half) %>%
  summarize(mean_turnout = mean(reg_byrv13, na.rm = TRUE))
```

```{r kenya11, exercise = TRUE}

```

```{r kenya11-hint}
kenya_plot <- ggplot(data = ..., aes(x = ..., y = ...)) +
  ...
```

```{r kenya11-hint-2}
# Remember to use geom_col() instead of geom_bar() when you map something to the y-axis.
```

### Exercise 12 

Already, we can see that one of the treatments is significantly more effective at increasing turnout than others. Continue by using `facet_wrap()` to facet the data by `age_half`. Don't forget to reassign this as `kenya_plot`. 

```{r kenya12-setup}
kenya_subset <- kenya %>%
  filter(treatment %in% c("control", "local", "SMS", "canvass")) %>%
  droplevels() %>%
  select(treatment, mean_age, reg_byrv13) %>%
  drop_na(mean_age) %>%
  mutate(age_half = ntile(mean_age, 2)) %>%
  group_by(treatment, age_half) %>%
  summarize(mean_turnout = mean(reg_byrv13, na.rm = TRUE))

kenya_plot <- ggplot(data = kenya_subset, 
                     mapping = aes(x = treatment, y = mean_turnout)) +
    geom_col()
```

```{r kenya12, exercise = TRUE}

```

```{r kenya12-hint}
kenya_plot <- kenya_plot +
  facet_wrap(~ ...)
```


### Exercise 13

To make the graph easier to read, use `fct_reorder()` to reorder the `treatment` variable by `mean_turnout`. Call this new plot `kenya_plot_2`. Note, you will no longer use the `facet_wrap()`, as this will cause issues with the ordering of the `treatment` categories.

```{r kenya13-setup}
kenya_subset <- kenya %>%
  filter(treatment %in% c("control", "local", "SMS", "canvass")) %>%
  droplevels() %>%
  select(treatment, mean_age, reg_byrv13) %>%
  drop_na(mean_age) %>%
  mutate(age_half = ntile(mean_age, 2)) %>%
  group_by(treatment, age_half) %>%
  summarize(mean_turnout = mean(reg_byrv13, na.rm = TRUE))
```

```{r kenya13, exercise = TRUE}

```

```{r kenya13-hint, eval = FALSE}
kenya_plot_2 <- ggplot(data = ..., mapping = aes(x = fct_reorder(..., ...), y = ...)) +
    geom_col()
```

### Exercise 14

Improve the aesthetics of the graph by changing the theme to `theme_bw()`.

```{r kenya14-setup}
kenya_subset <- kenya %>%
  filter(treatment %in% c("control", "local", "SMS", "canvass")) %>%
  droplevels() %>%
  select(treatment, mean_age, reg_byrv13) %>%
  drop_na(mean_age) %>%
  mutate(age_half = ntile(mean_age, 2)) %>%
  group_by(treatment, age_half) %>%
  summarize(mean_turnout = mean(reg_byrv13, na.rm = TRUE))

kenya_plot_2 <- ggplot(data = kenya_subset,
                       mapping = aes(x = fct_reorder(treatment, mean_turnout), y = mean_turnout)) +
    geom_col()
```

```{r kenya14, exercise = TRUE}

```

```{r kenya14-hint}
kenya_plot_2 <- kenya_plot_2 +
  ...
```

### Exercise 15

Great job! This graph allows us to see that the presence of a local administrator at the polling location is by far the most effective strategy for increasing voter turnout. In addition, older voters (category 2) are not only more likely to vote than younger voters, but they are also influenced to a greater extent by the presence of a local administrator.

To finish your plot, use `labs()` to change the x-axis label to "treatment." In addition, give the graph a title and subtitle of your choosing.

```{r kenya15-setup}
kenya_subset <- kenya %>%
  filter(treatment %in% c("control", "local", "SMS", "canvass")) %>%
  droplevels() %>%
  select(treatment, mean_age, reg_byrv13) %>%
  drop_na(mean_age) %>%
  mutate(age_half = ntile(mean_age, 2)) %>%
  group_by(treatment, age_half) %>%
  summarize(mean_turnout = mean(reg_byrv13, na.rm = TRUE))

kenya_plot_2 <- ggplot(data = kenya_subset,
                       mapping = aes(x = fct_reorder(treatment, mean_turnout), y = mean_turnout)) +
    geom_col() +
    theme_bw()
```

```{r kenya15, exercise = TRUE}

```

```{r kenya15-hint}
kenya_plot_2 + 
    labs(...)
```

## Data Wrangling: sps
### Exercise 1 

The `sps` data set from the PPBDS.data pakcage contains information about a study done on a popular Mexican health insurance program, Seguro Popular. In the study, some Mexican health clusters were randomly "treated." The treatment consisted of encouragement for people in that health cluster to enroll in the health insurance program, as well as funds to improve health facilities in the cluster.

Start by calling `glimpse()` on `sps`.

```{r sps1-setup}
PPBDS.data::sps
```

```{r sps1, exercise = TRUE}

```

```{r sps1-hint}
glimpse(...)
```

### Exercise 2

Using a pipe and the `%in%` operator, `filter()` `sps` to the observations with an `education` of "preschool," "secondary," "high school," or "college." Save this new dataset as `sps_subset`.

```{r sps2-setup}
PPBDS::sps
```

```{r sps2, exercise = TRUE}

```

```{r sps2-hint-1}
... <- sps %>%
  filter(education %in% ...)
```

```{r sps2-hint-2}
... <- sps %>% 
  filter(education %in% c(...))
```

### Exercise 3

Use `select()` to remove the columns `health_exp_1m` and `t2_health_exp_1m` (these measure health expenses over the past month, whereas `health_exp_3m` and `t2_health_exp_3m` measure health expenses over the past 3 months). Resave this as `sps_subset`.

```{r sps3-setup}
sps_subset <- sps %>%
  filter(education %in% c("preschool", "secondary", "high school", "college"))
```

```{r sps3, exercise = TRUE}

```

```{r sps3-hint-1}
# Remember that select(-column_name) returns all columns except for that column.
```

```{r sps3-hint-2}
# Consider using c()
```


### Exercise 4 

`mutate()` a new variable, `change_in_expenses`, equal to `health_exp_3m` subtracted from `t2_health_exp_3m` (this measures the change in expenses after the treatment period). Resave this as `sps_subset`.

```{r sps4-setup}
sps_subset <- sps %>%
  filter(education %in% c("preschool", "secondary", "high school", "college")) %>%
  select(-c(health_exp_1m, t2_health_exp_1m))
```

```{r sps4, exercise = TRUE}

```

### Exercise 5

Group the data by `treatment` and `education`.

```{r sps5-setup}
sps_subset <- sps %>%
  filter(education %in% c("preschool", "secondary", "high school", "college")) %>%
  select(-c(health_exp_1m, t2_health_exp_1m)) %>% 
  mutate(change_in_expenses = t2_health_exp_3m - health_exp_3m)
```

```{r sps5, exercise = TRUE}

```

```{r sps5-hint}
# Use the group_by() function.
```

### Exercise 6

Using `summarize()`, calculate `mean_change_in_expenses`, the average of the `change_in_expenses` for each group.

```{r sps6-setup}
sps_subset <- sps %>%
  filter(education %in% c("preschool", "secondary", "high school", "college")) %>%
  select(-c(health_exp_1m, t2_health_exp_1m)) %>% 
  mutate(change_in_expenses = t2_health_exp_3m - health_exp_3m) %>%
  group_by(treatment, education)
```

```{r sps6, exercise = TRUE}
  
```

```{r sps6-hint, eval = FALSE}
# Use the summarize() function and the helper function mean()
```

### Exercise 7

Call `ggplot()` to make a bar graph that maps `education` to the x-axis, `mean_change_in_expenses` to the y-axis, and `treatment` to the fill aesthetic. Call this plot `sps_plot`. 

```{r sps7-setup}
sps_subset <- sps %>%
  filter(education %in% c("preschool", "secondary", "high school", "college")) %>%
  select(-c(health_exp_1m, t2_health_exp_1m)) %>%
  mutate(change_in_expenses = t2_health_exp_3m - health_exp_3m) %>%
  group_by(treatment, education) %>%
  summarize(mean_change_in_expenses = mean(change_in_expenses))
```

```{r sps7, exercise = TRUE}

```

```{r sps7-hint}
# Remember to use geom_col() instead of geom_bar() when mapping a variable to the y-axis.
```

### Exercise 8 

Use the `position_dodge` function with `preserve` equal to "single" to create a dodged barplot. Does it work?

```{r sps8-setup}
sps_subset <- sps %>%
  filter(education %in% c("preschool", "secondary", "high school", "college")) %>%
  select(-c(health_exp_1m, t2_health_exp_1m)) %>%
  mutate(change_in_expenses = t2_health_exp_3m - health_exp_3m) %>%
  group_by(treatment, education) %>%
  summarize(mean_change_in_expenses = mean(change_in_expenses))

sps_plot <- ggplot(data = sps_subset, mapping = aes(x = education, y = mean_change_in_expenses, fill = treatment)) +
    geom_col()
```

```{r sps8, exercise = TRUE}

```

```{r sps8-hint}
# You can use the position argument in the geom_col() layer
```

### Exercise 9

Because `treatment` column of `sps_subset` is an integer and not a factor, we can't group our data by it. To fix this problem, use `mutate()` and `as.factor()`. 

```{r sps9-setup}
sps_subset <- sps %>%
  filter(education %in% c("preschool", "secondary", "high school", "college")) %>%
  select(-c(health_exp_1m, t2_health_exp_1m)) %>%
  mutate(change_in_expenses = t2_health_exp_3m - health_exp_3m) %>%
  group_by(treatment, education) %>%
  summarize(mean_change_in_expenses = mean(change_in_expenses))
```

```{r sps9, exercise = TRUE}

```

```{r sps9-hint}
# We want to set our new variable to as.factor(treatment)
```

### Exercise 10

Make a new graph `sps_plot_2` and use `fct_reorder()` to reorder the four educations by `mean_change_in_expenses`.

```{r sps10-setup}
sps_subset <- sps %>%
  filter(education %in% c("preschool", "secondary", "high school", "college")) %>%
  select(-c(health_exp_1m, t2_health_exp_1m)) %>%
  mutate(change_in_expenses = t2_health_exp_3m - health_exp_3m) %>%
  group_by(treatment, education) %>%
  summarize(mean_change_in_expenses = mean(change_in_expenses)) %>%
  mutate(treatment = as.factor(treatment))
```

```{r sps10, exercise = TRUE}

```

```{r sps10-hint}
# Look at Question 13 of the Data Wrangling: Kenya section if you are confused 
# about the fct_reorder() function 
```

### Exercise 11

Change the aesthetics of the plot by using `scale_fill_brewer()` with the "Paired" palette. In addition, adjust the `labels` argument of `scale_fill_brewer()` so that the legend's labels are equal to the vector ("No", "Yes").

```{r sps11-setup}
sps_subset <- sps %>%
  filter(education %in% c("preschool", "secondary", "high school", "college")) %>%
  select(-c(health_exp_1m, t2_health_exp_1m)) %>%
  mutate(change_in_expenses = t2_health_exp_3m - health_exp_3m) %>%
  group_by(treatment, education) %>%
  summarize(mean_change_in_expenses = mean(change_in_expenses)) %>%
  mutate(treatment = as.factor(treatment))
sps_plot_2 <- ggplot(data = sps_subset, mapping = aes(x = fct_reorder(education, mean_change_in_expenses), y = mean_change_in_expenses, fill = treatment)) +
    geom_col(position = position_dodge(preserve = "single"))
```

```{r sps11, exercise = TRUE}

```

```{r sps11-hint}
sps_plot_2 <- sps_plot_2 + 
    scale_fill_brewer(palette = ..., labels = ...)
```

### Exercise 12

Finally, add `theme_minimal()` to change the style of the graph.

```{r sps12-setup}
sps_subset <- sps %>%
  filter(education %in% c("preschool", "secondary", "high school", "college")) %>%
  select(-c(health_exp_1m, t2_health_exp_1m)) %>%
  mutate(change_in_expenses = t2_health_exp_3m - health_exp_3m) %>%
  group_by(treatment, education) %>%
  summarize(mean_change_in_expenses = mean(change_in_expenses)) %>%
  mutate(treatment = as.factor(treatment))
sps_plot_2 <- ggplot(data = sps_subset, mapping = aes(x = fct_reorder(education, mean_change_in_expenses), y = mean_change_in_expenses, fill = treatment)) +
    geom_col(position = position_dodge(preserve = "single")) + 
  scale_fill_brewer(palette = "Paired", labels = c("No", "Yes"))
```

```{r sps12, exercise = TRUE}

```

### Exercise 13

Great work! The first thing to notice from our graph is that all of the bars are positive, implying that all medical costs (regardless of treatment) went up over time. However, it is also clear that the treatment significantly lowered costs for all education groups. Finally, it is worth noting that the education category `preschool` is the only category that the treatment did not significantly affect. Since the treatment was designed to help less educated people the most, this is definitely a fact worth investigating.

To finish your plot, use `labs()` to change the x-axis label to "education." Also, give the graph a title and subtitle of your choice.

```{r sps13-setup}
sps_subset <- sps %>%
  filter(education %in% c("preschool", "secondary", "high school", "college")) %>%
  select(-c(health_exp_1m, t2_health_exp_1m)) %>%
  mutate(change_in_expenses = t2_health_exp_3m - health_exp_3m) %>%
  group_by(treatment, education) %>%
  summarize(mean_change_in_expenses = mean(change_in_expenses)) %>%
  mutate(treatment = as.factor(treatment))
sps_plot_2 <- ggplot(data = sps_subset, mapping = aes(x = fct_reorder(education, mean_change_in_expenses), y = mean_change_in_expenses, fill = treatment)) +
    geom_col(position = position_dodge(preserve = "single")) + 
  scale_fill_brewer(palette = "Paired", labels = c("No", "Yes")) +
    theme_minimal()
```

```{r sps13, exericse = TRUE}

```

## Data Wrangling: shaming

### Exercise 1

The `shaming` data set chronicles a study that attempted to measure the impact of social pressure on voting. Nearly 350,000 people in Michigan were randomly assigned to 1 of 5 treatment groups before the 2006 Michigan primary. All 5 groups were sent mail before the primary: the "Civic Duty" group had an extra reminder that voting was a civic responsibility, the "Hawthorne" group was told that whether or not they voted would be in the public record, the "Self" group was actually *sent* the public record of whether or not they voted in 2004, and the "Neighbors" group was sent both their voting record and their neighbors' voting record from 2004.

Start by running `skim()` on `shaming`. See if you can find out how many of the participants voted in `general_04`. Also, pay close attention to the data types of each of the variables.

```{r shaming1, exercise = TRUE}

```

### Exercise 2

Make the data set easier to visualize by limiting the columns to `treatment`, `primary_04`, and `primary_06`. Call this new dataset `shaming_subset`.

```{r shaming2, exercise = TRUE}

```

```{r shaming2-hint}
# Use the select() function.
```

### Exercise 3

Use `pivot_longer()` to map the *names* of the `primary_04` and `primary_06` columns to a new column, "year," and the *values* of those two columns to a new column, "voted." What goes wrong?

```{r shaming3-setup}
shaming_subset <- shaming %>%
  select(primary_04, primary_06, treatment)
```

```{r shaming3, exercise = TRUE}

```

```{r shaming3-hint, eval = FALSE}
shaming_subset %>%
  pivot_longer(cols = ..., names_to = ..., values_to = ...)
```

### Exercise 4

`pivot_longer()` won't let us combine one column of `<chr>` data with one column of `<int>` data. Therefore, we're going to have to change the data type of one of the columns.

Before we do that, though, we need to understand the dplyr `if_else()` function. `if_else()` is used alongside `mutate()` to create 2 different values depending on whether a `condition` is `TRUE` or `FALSE`. Run the following code to see how we can categorize the `birth_year` column into 2 groups based on whether the person was born before 1950.

```{r shaming4, exercise = TRUE, exercise.lines = 6}
shaming %>%
  select(birth_year) %>%
  mutate(born_before_1950 = if_else(condition = birth_year < 1950,
                                 true = "yes",
                                 false = "no"))
```

### Exercise 5

Now, use `if_else()` before the `pivot_longer()` statement to `mutate()` the `primary_04` column. The condition should should be a `str_detect()` of the string "Yes" in `primary_04`. If the condition is true, return 1 **as an integer**, and if the condition is false, return 0 **as an integer**.

```{r shaming5-setup}
shaming_subset <- shaming %>%
  select(primary_04, primary_06, treatment) 
```

```{r shaming5, exercise = TRUE, eval = FALSE, exercise.lines = 5}

```

```{r shaming5-hint-1}
# Remember to append the letter "L" to make something an integer; e.g. 22L.
```

```{r shaming5-hint-2}
# The condition of the if_else() should be str_detect(primary_04, "Yes").
```

### Exercise 6

Great job! To continue, group the data by `treatment`, `year`, and `voted`.

```{r shaming6-setup}
shaming_subset <- shaming %>%
  select(primary_04, primary_06, treatment) %>%
  mutate(primary_04 = if_else(condition = str_detect(primary_04, "Yes"),
                              true = 1L,
                              false = 0L)) %>%
  pivot_longer(cols = c(primary_04, primary_06), names_to = "year", values_to = "voted")
```

```{r shaming6, exercise = TRUE}

```

```{r shaming6-hint}
# Use the group_by() function.
```

### Exercise 7

Using `summarize()`, create the variable `num_voters` that simply counts the number of rows in each group.

```{r shaming7-setup}
shaming_subset <- shaming %>%
  select(primary_04, primary_06, treatment) %>%
  mutate(primary_04 = if_else(condition = str_detect(primary_04, "Yes"),
                              true = 1L,
                              false = 0L)) %>%
  pivot_longer(cols = c(primary_04, primary_06), names_to = "year", values_to = "voted") %>%
  group_by(treatment, year, voted)
```

```{r shaming7, exercise = TRUE}

```

```{r shaming7-hint}
# Remember that n() counts the number of rows in each group.
```

### Exercise 8

The `voted` column is a bit difficult to understand, as a numerical value (0 or 1) is used to represent an idea (the person did or did not vote). Use another `if_else()` statement to `mutate()` the `voted` column. Condition your `if_else()` on whether `voted` is equal to 1: true should return "did_vote," and false should return "did_not_vote."

```{r shaming8-setup}
shaming_subset <- shaming %>%
  select(primary_04, primary_06, treatment) %>%
  mutate(primary_04 = if_else(condition = str_detect(primary_04, "Yes"),
                              true = 1L,
                              false = 0L)) %>%
  pivot_longer(cols = c(primary_04, primary_06), names_to = "year", values_to = "voted") %>%
  group_by(treatment, year, voted) %>%
  summarize(num_voters = n())
```

```{r shaming8, exercise = TRUE}

```

```{r shaming8-hint}
# The condition of the if_else() should be voted == 1.
```

### Exercise 9

Now, we want `did_vote` and `did_not_vote` to be their own columns. Call a `pivot_wider()` function that gets its column names from `voted` and its values from `num_voters`.

```{r shaming9-setup}
shaming_subset <- shaming %>%
  select(primary_04, primary_06, treatment) %>%
  mutate(primary_04 = if_else(condition = str_detect(primary_04, "Yes"),
                              true = 1L,
                              false = 0L)) %>%
  pivot_longer(cols = c(primary_04, primary_06), names_to = "year", values_to = "voted") %>%
  group_by(treatment, year, voted) %>%
  summarize(num_voters = n()) %>%
  mutate(voted = if_else(condition = voted == 1,
                         true = "did_vote",
                         false = "did_not_vote"))
```

```{r shaming9, exercise = TRUE}

```

```{r shaming9-hint, eval = FALSE}
shaming_subset <- shaming_subset %>%
  pivot_wider(names_from = ..., values_from = ...)
```

### Exercise 10

`mutate()` a new variable, `pct_voted`, equal to the number of people who `did_vote` divided by the total number of people.

```{r shaming10-setup}
shaming_subset <- shaming %>%
  select(primary_04, primary_06, treatment) %>%
  mutate(primary_04 = if_else(condition = str_detect(primary_04, "Yes"),
                              true = 1L,
                              false = 0L)) %>%
  pivot_longer(cols = c(primary_04, primary_06), names_to = "year", values_to = "voted") %>%
  group_by(treatment, year, voted) %>%
  summarize(num_voters = n()) %>%
  mutate(voted = if_else(condition = voted == 1,
                         true = "did_vote",
                         false = "did_not_vote")) %>%
  pivot_wider(names_from = voted, values_from = num_voters)
```

```{r shaming10, exercise = TRUE}

```

```{r shaming10-hint}
# Note that the total number of people is equal to (did_vote + did_not_vote).
```

### Exercise 11

Call `ggplot()` to make a bar chart that maps `treatment` to the x-axis, `pct_voted` to the y-axis, and `year` to the fill aesthetic. Call this plot `shaming_plot`.

```{r shaming11-setup}
shaming_subset <- shaming %>%
  select(primary_04, primary_06, treatment) %>%
  mutate(primary_04 = if_else(condition = str_detect(primary_04, "Yes"),
                              true = 1L,
                              false = 0L)) %>%
  pivot_longer(cols = c(primary_04, primary_06), names_to = "year", values_to = "voted") %>%
  group_by(treatment, year, voted) %>%
  summarize(num_voters = n()) %>%
  mutate(voted = if_else(condition = voted == 1,
                         true = "did_vote",
                         false = "did_not_vote")) %>%
  pivot_wider(names_from = voted, values_from = num_voters)
```

```{r shaming11, exercise = TRUE, exercise.lines = 14}

```

```{r shaming11-hint}
# Remember to use geom_col() instead of geom_bar() when you map something to the y-axis.
```

### Exercise 12

A stacked barplot is very hard to analyze here. Use the `position_dodge()` function with `preserve` set to "single" to make the graph a dodged barplot.

```{r shaming12-setup}
shaming_subset <- shaming %>%
  select(primary_04, primary_06, treatment) %>%
  mutate(primary_04 = if_else(condition = str_detect(primary_04, "Yes"),
                              true = 1L,
                              false = 0L)) %>%
  pivot_longer(cols = c(primary_04, primary_06), names_to = "year", values_to = "voted") %>%
  group_by(treatment, year, voted) %>%
  summarize(num_voters = n()) %>%
  mutate(voted = if_else(condition = voted == 1,
                         true = "did_vote",
                         false = "did_not_vote")) %>%
  pivot_wider(names_from = voted, values_from = num_voters)

shaming_plot <- ggplot(data = shaming_subset, mapping = aes(x = treatment, y = pct_voted, fill = year)) +
    geom_col()
```

```{r shaming12, exercise = TRUE}

```

```{r shaming12-hint, eval = FALSE}
# Set the position argument of geom_col()
```

### Exercise 13

Use `fct_reorder()` to reorder the five different `treatment`s by `pct_voted`. Call this new plot `shaming_plot_2`.

```{r shaming13-setup}
shaming_subset <- shaming %>%
  select(primary_04, primary_06, treatment) %>%
  mutate(primary_04 = if_else(condition = str_detect(primary_04, "Yes"),
                              true = 1L,
                              false = 0L)) %>%
  pivot_longer(cols = c(primary_04, primary_06), names_to = "year", values_to = "voted") %>%
  group_by(treatment, year, voted) %>%
  summarize(num_voters = n()) %>%
  mutate(voted = if_else(condition = voted == 1,
                         true = "did_vote",
                         false = "did_not_vote")) %>%
  pivot_wider(names_from = voted, values_from = num_voters)
```

```{r shaming13, exercise = TRUE}

```

### Exercise 14

Finally, use the `coord_cartesian` function to adjust the graph's zoom by setting `ylim` to the vector `(0.2, 0.45)`.

```{r shaming14-setup}
shaming_subset <- shaming %>%
  select(primary_04, primary_06, treatment) %>%
  mutate(primary_04 = if_else(condition = str_detect(primary_04, "Yes"),
                              true = 1L,
                              false = 0L)) %>%
  pivot_longer(cols = c(primary_04, primary_06), names_to = "year", values_to = "voted") %>%
  group_by(treatment, year, voted) %>%
  summarize(num_voters = n()) %>%
  mutate(voted = if_else(condition = voted == 1,
                         true = "did_vote",
                         false = "did_not_vote")) %>%
  pivot_wider(names_from = voted, values_from = num_voters)

shaming_plot_2 <- ggplot(data = shaming_subset, mapping = aes(x = fct_reorder(treatment, pct_voted), y = pct_voted, fill = year)) +
    geom_col(position = position_dodge(preserve = "single"))
```

```{r shaming14, exercise = TRUE}

```

### Exercise 15

From this graph, the first thing to notice is that all five of the treatment categories had approximately the same average voter turnout in 2004. We can also see that turnout decreased across the board in 2006. However, each additional level of social shaming led to a substantial increase in voter turnout, with the "Neighbors" treatment particularly effective.

To finish your plot, use `labs()` to change the x-axis label to "treatment." In addition, give the graph a title and subtitle of your choice.

```{r shaming15-setup}
shaming_subset <- shaming %>%
  select(primary_04, primary_06, treatment) %>%
  mutate(primary_04 = if_else(condition = str_detect(primary_04, "Yes"),
                              true = 1L,
                              false = 0L)) %>%
  pivot_longer(cols = c(primary_04, primary_06), names_to = "year", values_to = "voted") %>%
  group_by(treatment, year, voted) %>%
  summarize(num_voters = n()) %>%
  mutate(voted = if_else(condition = voted == 1,
                         true = "did_vote",
                         false = "did_not_vote")) %>%
  pivot_wider(names_from = voted, values_from = num_voters)

shaming_plot_2 <- ggplot(data = shaming_subset, 
                         mapping = aes(x = fct_reorder(treatment, pct_voted), y = pct_voted, fill = year)) +
    geom_col(position = position_dodge(preserve = "single")) +
    coord_cartesian(ylim = c(0.2, 0.45))
```

```{r shaming15, exercise = TRUE}

```

## Data Wrangling: qscores
### Exercise 1 

The `qscores` data set includes information about 748 courses at Harvard during the 2018-2019 school year, including their department, student enrollment, average time spent on homework, and the average student rating of the course.

Start by piping `qscores` into `sample_n()` to view 5 random rows in the data set.

```{r qscores1, exercise = TRUE}

```

### Exercise 2

Our goal will be to analyze the homework patterns of Harvard classes by department. To start, use a pipe to `select()` the `department` and `hours` columns (`hours` represents the average workload of a class per week in hours, based on student surveys). Call this new dataset `q_subset`. 

```{r qscores2, exercise = TRUE}

```

### Exercise 3

Next, group the data by `department`.
```{r qscores3-setup}
q_subset <- qscores %>%
  select(department, hours)
```

```{r qscores3, exercise = TRUE}

```

```{r qscores3-hint}
# Use the group_by() function.
```

### Exercise 4

Use `summarize()` to create 3 new variables: `num_classes` equal to the number of rows (i.e. classes) in each `department` group, `mean_hours` equal to the average value of `hours` by group, and `sd_hours` equal to the standard deviation (`sd()`) of `hours` by group.

```{r qscores4-setup}
q_subset <- qscores %>%
  select(department, hours) %>%
  group_by(department)
```

```{r qscores4, exercise = TRUE, exercise.lines = 4}

```

```{r qscores4-hint-1}
# The n() function returns the number of rows in each group.
```

```{r qscores4-hint-2, eval = FALSE}
q_subset <- q_subset %>%
  summarize(num_classes = ..., mean_hours = ..., sd_hours = ...)
```

### Exercise 5

`arrange()` the data set by `num_classes` in `desc()`ending order.

```{r qscores5-setup}
q_subset <- qscores %>%
  select(department, hours) %>%
  group_by(department) %>%
  summarize(num_classes = n(), mean_hours = mean(hours), sd_hours = sd(hours))
```

```{r qscores5, exercise = TRUE}

```

### Exercise 6

Use `slice()` to return the top 3 rows of the data set, i.e. the 3 largest departments at Harvard by number of classes.

```{r qscores6-setup}
q_subset <- qscores %>%
  select(department, hours) %>%
  group_by(department) %>%
  summarize(num_classes = n(), mean_hours = mean(hours), sd_hours = sd(hours)) %>%
  arrange(desc(num_classes))
```

```{r qscores6, exercise = TRUE}

```

```{r qscores6-hint}
# Remember that a:b returns all of the numbers from a to b. For example, 1:10 returns every number between 1 and 10.
```

### Exercise 7

Group the data by `department` one more time (the data is no longer grouped since we removed some `department`s with our `slice()` statement).

```{r qscores7-setup}
q_subset <- qscores %>%
  select(department, hours) %>%
  group_by(department) %>%
  summarize(num_classes = n(), mean_hours = mean(hours), sd_hours = sd(hours)) %>%
  arrange(desc(num_classes)) %>%
  slice(1:3)
```

```{r qscores7, exercise = TRUE}

```

### Exercise 8

Using `summarize()`, create a new variable, `rnorm_values`. `rnorm_values` should be equal to the result of an `rnorm()` statement. The `rnorm()` statement should have `n` equal to `num_classes`, `mean` equal to `mean_hours`, and `sd` equal to `sd_hours` (in other words, we are generating `n` completely random numbers, but the numbers should have the same mean and standard deviation as the actual Harvard classes do).

```{r qscores8-setup}
q_subset <- qscores %>%
  select(department, hours) %>%
  group_by(department) %>%
  summarize(num_classes = n(), mean_hours = mean(hours), sd_hours = sd(hours)) %>%
  arrange(desc(num_classes)) %>%
  slice(1:3) %>%
  group_by(department)
```

```{r qscores8, exercise = TRUE}

```

```{r qscores8-hint}
qsubset <- q_subset %>%
  summarize(rnorm_values = rnorm(...))
```

### Exercise 9

Great work! Our next goal will be to create a new column with the homework values of the *actual* Harvard classes. To do so, start a new pipe at the very beginning of your code. Use the pipe to `filter()` qscores to the "ECON," "MATH," and "GOV" departments (which we have already discovered are the 3 largest departments in our data set). Call this `q_subset_2`. 

```{r qscores9, exercise = TRUE}

```

```{r qscores9-hint}
# Remember to use the %in% operator.
```

### Exercise 10

`arrange()` both `q_subset` and `q_subset_2` by `department`. (because `department` is a character variable, this will arrange them in alphabetical order).

```{r qscores10-setup}
q_subset_2 <- qscores %>%
  filter(department %in% c("ECON", "MATH", "GOV"))
```

```{r qscores10, exercise = TRUE}

```

### Exercise 11

`select()` only the `hours` variable from `q_subset_2`.
```{r qscores11-setup}
q_subset_2 <- qscores %>%
  filter(department %in% c("ECON", "MATH", "GOV")) %>%
  arrange(department)

q_subset <- qscores %>%
  select(department, hours) %>%
  group_by(department) %>%
  summarize(num_classes = n(), mean_hours = mean(hours), sd_hours = sd(hours)) %>%
  arrange(desc(num_classes)) %>%
  slice(1:3) %>%
  group_by(department) %>%
  summarize(rnorm_values = rnorm(n = num_classes, mean = mean_hours, sd = sd_hours)) %>%
  arrange(department)

```

```{r qscores11, exercise = TRUE}

```

### Exercise 12 

Finally, use `bind_cols()` to bind the columns in `q_subset_2` to the columns in `q_subset`.
Call this `q_bind`.

Notice how careful we were to `arrange()` both pipes by the same variable before we conducted our column bind. This is really important because the rows **must** be in the same order before you column bind. Otherwise, values will be bound to the wrong rows (for example, some `hours` from ECON classes might end up paired with some `rnorm_values` from MATH classes, which we certainly don't want).

```{r qscores12-setup}
q_subset_2 <- qscores %>%
  filter(department %in% c("ECON", "MATH", "GOV")) %>%
  arrange(department) %>%
  select(hours)

q_subset <- qscores %>%
  select(department, hours) %>%
  group_by(department) %>%
  summarize(num_classes = n(), mean_hours = mean(hours), sd_hours = sd(hours)) %>%
  arrange(desc(num_classes)) %>%
  slice(1:3) %>%
  group_by(department) %>%
  summarize(rnorm_values = rnorm(n = num_classes, mean = mean_hours, sd = sd_hours)) %>%
  arrange(department)
```

```{r qscores12, exercise = TRUE}

```

### Exercise 13

Before we make our `ggplot()`, use `pivot_longer()` to transform the `rnorm_values` and `hours` columns into two new columns: "type," equal to either `rnorm_values` or `hours`, and "value," equal to the value currently contained in one of those two columns.

```{r qscores13-setup}
q_subset_2 <- qscores %>%
  filter(department %in% c("ECON", "MATH", "GOV")) %>%
  arrange(department) %>%
  select(hours)

q_subset <- qscores %>%
  select(department, hours) %>%
  group_by(department) %>%
  summarize(num_classes = n(), mean_hours = mean(hours), sd_hours = sd(hours)) %>%
  arrange(desc(num_classes)) %>%
  slice(1:3) %>%
  group_by(department) %>%
  summarize(rnorm_values = rnorm(n = num_classes, mean = mean_hours, sd = sd_hours)) %>%
  arrange(department)

q_bind <- bind_cols(q_subset, q_subset_2)
```

```{r qscores13, exercise = TRUE}

```

```{r qscores13-hint, eval = FALSE}

```

### Exercise 14

Use `ggplot()` to make a histogram that maps `value` to the x-axis. Give the histogram a `binwidth` of 2. Call this histogram `q_plot`. 
```{r qscores14-setup}
q_subset_2 <- qscores %>%
  filter(department %in% c("ECON", "MATH", "GOV")) %>%
  arrange(department) %>%
  select(hours)

q_subset <- qscores %>%
  select(department, hours) %>%
  group_by(department) %>%
  summarize(num_classes = n(), mean_hours = mean(hours), sd_hours = sd(hours)) %>%
  arrange(desc(num_classes)) %>%
  slice(1:3) %>%
  group_by(department) %>%
  summarize(rnorm_values = rnorm(n = num_classes, mean = mean_hours, sd = sd_hours)) %>%
  arrange(department)

q_bind <- bind_cols(q_subset, q_subset_2) %>%
  pivot_longer(cols = c(rnorm_values, hours), names_to = "type", values_to = "value")
```

```{r qscores14, exercise = TRUE}

```

### Exercise 15

Use `facet_grid()` to facet our histogram into rows by `type` and columns by `department`.
```{r qscores15-setup}
q_subset_2 <- qscores %>%
  filter(department %in% c("ECON", "MATH", "GOV")) %>%
  arrange(department) %>%
  select(hours)

q_subset <- qscores %>%
  select(department, hours) %>%
  group_by(department) %>%
  summarize(num_classes = n(), mean_hours = mean(hours), sd_hours = sd(hours)) %>%
  arrange(desc(num_classes)) %>%
  slice(1:3) %>%
  group_by(department) %>%
  summarize(rnorm_values = rnorm(n = num_classes, mean = mean_hours, sd = sd_hours)) %>%
  arrange(department)

q_bind <- bind_cols(q_subset, q_subset_2) %>%
  pivot_longer(cols = c(rnorm_values, hours), names_to = "type", values_to = "value")

q_plot <- ggplot(data = q_bind, mapping = aes(x = value)) +
    geom_histogram(binwidth = 2)
```

```{r qscores15, exercise = TRUE, exercise.lines = 19}

```

```{r qscores15-hint}
# Remember that when using facet_grid(), the variable to the left of the "~" is the variable that will be used to facet the graph into rows.
```

### Exercise 16

Awesome work! This graph gives the actual homework times for Harvard classes on the top row and an imitation on the bottom row by utilizing a normal distribution. The first thing to notice is that the MATH department has a significantly higher mean homework amount than the ECON and GOV departments (this is most easily seen on the bottom row of graphs). Furthermore, the graphs on the top tend to skew left compared to the normal distributions on the bottom, implying that professors are less willing to give substantially more homework than the typical class in that department.

To finish your plot, use `labs()` to give the graph a title and subtitle of your choice.

```{r qscores16-setup}
q_subset_2 <- qscores %>%
  filter(department %in% c("ECON", "MATH", "GOV")) %>%
  arrange(department) %>%
  select(hours)

q_subset <- qscores %>%
  select(department, hours) %>%
  group_by(department) %>%
  summarize(num_classes = n(), mean_hours = mean(hours), sd_hours = sd(hours)) %>%
  arrange(desc(num_classes)) %>%
  slice(1:3) %>%
  group_by(department) %>%
  summarize(rnorm_values = rnorm(n = num_classes, mean = mean_hours, sd = sd_hours)) %>%
  arrange(department)

q_bind <- bind_cols(q_subset, q_subset_2) %>%
  pivot_longer(cols = c(rnorm_values, hours), names_to = "type", values_to = "value")

q_plot <- ggplot(data = q_bind, mapping = aes(x = value)) +
    geom_histogram(binwidth = 2) +
     facet_grid(type ~ department)
```

```{r qscores16, exercise = TRUE, exercise.lines = 20}

```

```{r qscores16-hint, eval = FALSE}

```


## Data Wrangling: cces
###

The `cces` data set, an acronym for "Cooperative Congressional Election Study," includes the presidential approval (and a bunch of demographic data) from over 450,000 individual Americans.

Since this data set is so large, start by using `sample_n()` to return 10 random observations from `cces`.

```{r cces1, exercise = TRUE}
cces
```

###

Use `select()` and the `c()` function to remove the `news`, `econ`, `marstat`, and `approval_ch` variables.

```{r cces2, exercise = TRUE}
cces
```

```{r cces2-hint-1}
# Remember that select(-column_name) returns all of the columns in the data set except for that column.
```

```{r cces2-hint-2, eval = FALSE}
cces %>%
  select(-c(...))
```

###

Use `filter()` to limit the data to the years 2009-2016 (to keep the approval data limited to a single president, Obama). Try to use the `%in%` operator to keep your code concise and clear.

```{r cces3, exercise = TRUE}
cces %>%
  select(-c(news, econ, marstat, approval_ch))
```

```{r cces3-hint}
# Remember that c(a:b) makes a vector from a to b. For example, c(1:10) makes a vector with the numbers from 1 to 10.
```

###

Add a second parameter to the `filter` statement removing any observations with an `ideology` of "Not Sure" (this makes the trends in our data easier to detect).

```{r cces4, exercise = TRUE, exercise.lines = 4}
cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016))
```

###

Now that `cces` is organized, our goal will be to plot the relationship between `race`, `ideology`, and `approval` of President Obama. Start by grouping the data by `race` and `ideology`.

```{r cces5, exercise = TRUE, exercise.lines = 4}
cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure")
```

###

Use `summarize` to return a tibble with a new variable, `mean_approval`, that is equal to the average `approval` for each group. What goes wrong?

```{r cces6, exercise = TRUE, exercise.lines = 5}
cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology)
```

```{r cces6-hint, eval = FALSE}
cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(...))
```

###

Almost all of our rows have an `NA` for `mean_approval`! This is because if any single row has an `NA` in our original table, the `mean()` function will return `NA`. To avoid this, change `mean()`'s `na.rm` argument so it removes values of `NA` before running.

```{r cces7, exercise = TRUE, exercise.lines = 6}
cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval))
```

```{r cces7-hint, eval = FALSE}
cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval, ...))
```

###

Add a `ggplot()` call that makes a bar chart with `ideology` on the x-axis, `mean_approval` on the y-axis, and `race` as the fill aesthetic.

```{r cces8, exercise = TRUE, exercise.lines = 6}
cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval, na.rm = TRUE))
```

```{r cces8-hint}
# Remember to use geom_col() instead of geom_bar() when you map a variable to the y-axis.
```

###

This stacked bar chart is a good start, but it's still pretty difficult to understand. Use the `position_dodge` function with `preserve` equal to "single" to make the graph clearer.

```{r cces9, exercise = TRUE, exercise.lines = 8}
cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval, na.rm = TRUE)) %>%
  ggplot(mapping = aes(x = ideology, y = mean_approval, fill = race)) +
    geom_col()
```

```{r cces9-hint, eval = FALSE}
cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval, na.rm = TRUE)) %>%
  ggplot(mapping = aes(x = ideology, y = mean_approval, fill = race)) +
    geom_col(position = ...)
```

###

Bar charts are easier to read if they are increasing from left to right. Use an `fct_` function to reorder the chart based on each `ideology`'s `mean_approval`.

<!-- Comment: technically there are separate mean_approval values for each race; is there any way to get around this (i.e. only sort by the values for one race?) Or would this just sort by the average of mean_approval? -->

```{r cces10, exercise = TRUE, exercise.lines = 8}
cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval, na.rm = TRUE)) %>%
  ggplot(mapping = aes(x = ideology, y = mean_approval, fill = race)) +
    geom_col(position = position_dodge(preserve = "single"))
```

```{r cces10-hint}
# Try using fct_reorder().
```

###

Our graph is looking good, but the 8 separate races take up a lot of space and make it hard to read. Let's try to limit the graph to the 3 most common races in our data set. Start by making a new pipe that groups `cces` by `race`.

```{r cces11, exercise = TRUE, exercise.lines = 10, eval = FALSE}
cces %>%
  ...

cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval, na.rm = TRUE)) %>%
  ggplot(mapping = aes(x = fct_reorder(ideology, mean_approval), y = mean_approval, fill = race)) +
    geom_col(position = position_dodge(preserve = "single"))
```

###

Next, use `summarize()` on the top pipe to create a new variable, `num_ppl`, equal to the number of times each race occurs.

```{r cces12, exercise = TRUE, exercise.lines = 11}
cces %>%
  group_by(race)

cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval, na.rm = TRUE)) %>%
  ggplot(mapping = aes(x = fct_reorder(ideology, mean_approval), y = mean_approval, fill = race)) +
    geom_col(position = position_dodge(preserve = "single"))
```

```{r cces12-hint}
# Remember that the function n() counts the number of rows in each group.
```

###

`arrange()` the summarized pipe by `num_ppl` in descending order.

```{r cces12-13, exercise = TRUE, exercise.lines = 12}
cces %>%
  group_by(race) %>%
  summarize(num_ppl = n())

cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval, na.rm = TRUE)) %>%
  ggplot(mapping = aes(x = fct_reorder(ideology, mean_approval), y = mean_approval, fill = race)) +
    geom_col(position = position_dodge(preserve = "single"))
```

```{r cces12-13-hint}
# Remember to incorporate desc() into your arrange() function.
```

###

Finally, use `slice()` to keep the top 3 rows of the arranged pipe. Save the entire pipe to `most_common_races`.

```{r cces13, exercise = TRUE, exercise.lines = 13}
cces %>%
  group_by(race) %>%
  summarize(num_ppl = n()) %>%
  arrange(desc(num_ppl))

cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval, na.rm = TRUE)) %>%
  ggplot(mapping = aes(x = fct_reorder(ideology, mean_approval), y = mean_approval, fill = race)) +
    geom_col(position = position_dodge(preserve = "single"))
```

```{r cces13-hint, eval = FALSE}
most_common_races <- cces %>%
  group_by(race) %>%
  summarize(num_ppl = n()) %>%
  arrange(desc(num_ppl)) %>%
  slice(...)

cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval, na.rm = TRUE)) %>%
  ggplot(mapping = aes(x = fct_reorder(ideology, mean_approval), y = mean_approval, fill = race)) +
    geom_col(position = position_dodge(preserve = "single"))
```

```{r most-common-races}
most_common_races <- cces %>%
  group_by(race) %>%
  summarize(num_ppl = n()) %>%
  arrange(desc(num_ppl)) %>%
  slice(1:3)
```

###

Returning to our original pipe, use a filtering join before our `ggplot()` call so that only the races in `most_common_races` remain in the pipe.

```{r cces14, exercise = TRUE, exercise.setup = "most-common-races", exercise.lines = 15}
most_common_races <- cces %>%
  group_by(race) %>%
  summarize(num_ppl = n()) %>%
  arrange(desc(num_ppl)) %>%
  slice(1:3)

cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval, na.rm = TRUE)) %>%
  ...
  ggplot(mapping = aes(x = fct_reorder(ideology, mean_approval), y = mean_approval, fill = race)) +
    geom_col(position = position_dodge(preserve = "single"))
```

```{r cces14-hint-1}
# Did you remember to use semi_join()?
```

```{r cces14-hint-2, eval = FALSE}
cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval, na.rm = TRUE)) %>%
  semi_join(..., by = ...)
  ggplot(mapping = aes(x = fct_reorder(ideology, mean_approval), y = mean_approval, fill = race)) +
    geom_col(position = position_dodge(preserve = "single"))
```

###

Our graph is starting to look good! To improve the aesthetics, add a `scale_` function to use RColorBrewer's "Dark2" palette to fill the bars.

```{r cces15, exercise = TRUE, exercise.setup = "most-common-races", exercise.lines = 15}
most_common_races <- cces %>%
  group_by(race) %>%
  summarize(num_ppl = n()) %>%
  arrange(desc(num_ppl)) %>%
  slice(1:3)

cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval, na.rm = TRUE)) %>%
  semi_join(most_common_races, by = "race") %>%
  ggplot(mapping = aes(x = fct_reorder(ideology, mean_approval), y = mean_approval, fill = race)) +
    geom_col(position = position_dodge(preserve = "single"))
```

```{r cces15-hint-1}
# Remember that because we want to change the fill aesthetic (and not the color aesthetic), we have to adjust the syntax of our scale_ function
```

```{r cces15-hint-2, eval = FALSE}
cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval, na.rm = TRUE)) %>%
  semi_join(most_common_races, by = "race") %>%
  ggplot(mapping = aes(x = fct_reorder(ideology, mean_approval), y = mean_approval, fill = race)) +
    geom_col(position = position_dodge(preserve = "single")) +
    scale_fill_brewer(...)
```

###

Great job! We can now clearly see the trend that more liberal Americans had a higher approval of President Obama. In addition, Black Americans gave Obama higher approval than Hispanic Americans, who, in turn, gave Obama higher approval than white Americans.

To finish your plot, use `labs()` to change the x-axis label so it simply reads as "ideology." In addition, give the graph a title and subtitle of your choosing. 

```{r cces16, exercise = TRUE, exercise.lines = 16, exercise.setup = "most-common-races"}
most_common_races <- cces %>%
  group_by(race) %>%
  summarize(num_ppl = n()) %>%
  arrange(desc(num_ppl)) %>%
  slice(1:3)

cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval, na.rm = TRUE)) %>%
  semi_join(most_common_races, by = "race") %>%
  ggplot(mapping = aes(x = fct_reorder(ideology, mean_approval), y = mean_approval, fill = race)) +
    geom_col(position = position_dodge(preserve = "single")) +
    scale_fill_brewer(palette = "Dark2")
```

```{r cces16-hint, eval = FALSE}
cces %>%
  select(-c(news, econ, marstat, approval_ch)) %>%
  filter(year %in% c(2009:2016), ideology != "Not Sure") %>%
  group_by(race, ideology) %>%
  summarize(mean_approval = mean(approval, na.rm = TRUE)) %>%
  semi_join(most_common_races, by = "race") %>%
  ggplot(mapping = aes(x = fct_reorder(ideology, mean_approval), y = mean_approval, fill = race)) +
    geom_col(position = position_dodge(preserve = "single")) +
    scale_fill_brewer(palette = "Dark2") +
    labs(...)
```









## Data Wrangling: governors
###

The `governors` data set contains information about gubernatorial candidates in the United States from 1945 to 2012, including how they did in the election and how long they lived after the election (all of the candidates in the data set have died as of the year 2019).

Start by simply typing `governors` in the code chunk below to see all of the different variables in the data set. Make sure to note the data types of the variables.

```{r governors1, exercise = TRUE}

```

###

Run `summary()` on governors.

```{r governors2, exercise = TRUE}

```

###

Our end goal is, among other things, to determine the impact of running *against* an incumbent in a gubernatorial race. However, there is no variable for this currently in the data set. To start, group `governors` by `year` and `state` (these two variables together determine each unique election).

```{r governors3, exercise = TRUE}
governors
```

###

The dplyr `n_distinct()` function returns the number of distinct values in any column of a data set. Run the code below to see how we can use `n_distinct()` to calculate the number of gubernatorial elections per state in the `governors` data set.

```{r governors3-4, exercise = TRUE, exercise.lines = 4}
governors %>%
  group_by(state) %>%
  summarize(num_elections = n_distinct(year))
```

###

Using `summarize()` and `n_distinct()`, create a new variable, `no_incumbent`, that returns `TRUE` if there is no incumbent in the race and `FALSE` otherwise. Note that there is no incumbent in the race if **both** of the following are true: the group has 1 distinct value of status, and the first value of status in the group is "Challenger."

Save your completed pipe to `governor_incumbents`.

```{r governors4, exercise = TRUE}
governors %>%
  group_by(year, state)
```

```{r governors4-hint-1}
# Use n_distinct() to check if there is 1 distinct value of status in a given group. 
```

```{r governors4-hint-2}
# The first value of status in each group is status[1].
```

###

Next, use a mutating join to add the `no_incumbent` variable to the `governors` pipe below (we want to keep all of the other variables in `governors` as well).

```{r governors5, exercise = TRUE, exercise.lines = 7, eval = FALSE}
governor_incumbents <- governors %>%
  group_by(year, state) %>%
  summarize(no_incumbent = (n_distinct(status) == 1 & status[1] == "Challenger"))

governors %>%
  ...
```

```{r governors5-hint, eval = FALSE}
governor_incumbents <- governors %>%
  group_by(year, state) %>%
  summarize(no_incumbent = (n_distinct(status) == 1 & .$status[1] == "Challenger"))

governors %>%
  left_join(...)
```

```{r governor-incumbents}
governor_incumbents <- governors %>%
  group_by(year, state) %>%
  summarize(no_incumbent = (n_distinct(status) == 1 & .$status[1] == "Challenger"))
```

###

Add to the bottom pipe by removing the variables `state`, `first_name`, `last_name`, `party`, and `sex` from the tibble.

```{r governors6, exercise = TRUE, exercise.lines = 7, exercise.setup = "governor-incumbents"}
governor_incumbents <- governors %>%
  group_by(year, state) %>%
  summarize(no_incumbent = (n_distinct(status) == 1 & status[1] == "Challenger"))

governors %>%
  left_join(governor_incumbents, by = c("year", "state"))
```

```{r governors6-hint}
# Remember that select(-column_name) removes that column.
```

###

Our next goal is to create a new variable for the age of each gubernatorial candidate at the time that they ran for office.

To start, `mutate()` a new variable, `birth_date`, that calculates each candidate's date of birth by subtracting `alive_post` and `alive_pre` from the `died` variable (i.e. the variable representing the candidate's date of death).

Remember that `alive_post` and `alive_pre` count the number of *days* that the candidate lived after and before the date of the election, so you'll have to use the lubridate `days()` function to convert `alive_post` and `alive_pre` into a period of time.

```{r governors7, exercise = TRUE, exercise.setup = "governor-incumbents", exercise.lines = 8}
governor_incumbents <- governors %>%
  group_by(year, state) %>%
  summarize(no_incumbent = (n_distinct(status) == 1 & status[1] == "Challenger"))

governors %>%
  left_join(governor_incumbents, by = c("year", "state")) %>%
  select(-c(state, first_name, last_name, party, sex))
```

```{r governors7-hint}
# days(alive_post + alive_pre) returns the total period of time that a candidate has been alive.
```

###

Next, `mutate()` another variable, `age`, that is calculated by subtracting the candidate's year of birth from the year of the election.

```{r governors8, exercise = TRUE, exercise.setup = "governor-incumbents", exercise.lines = 9}
governor_incumbents <- governors %>%
  group_by(year, state) %>%
  summarize(no_incumbent = (n_distinct(status) == 1 & status[1] == "Challenger"))

governors %>%
  left_join(governor_incumbents, by = c("year", "state")) %>%
  select(-c(state, first_name, last_name, party, sex)) %>%
  mutate(birth_date = died - days(alive_post + alive_pre))
```

```{r governors8-hint}
# year(birth_date) returns the year of the candidate's birth date.
```

###

Use `mutate()` again to create the variable `age_range`, equal to the candidate's `age` rounded down to a multiple of 5. To do this, subtract `age %% 5` from `age`.

```{r governors9, exercise = TRUE, exercise.setup = "governor-incumbents", exercise.lines = 10}
governor_incumbents <- governors %>%
  group_by(year, state) %>%
  summarize(no_incumbent = (n_distinct(status) == 1 & status[1] == "Challenger"))

governors %>%
  left_join(governor_incumbents, by = c("year", "state")) %>%
  select(-c(state, first_name, last_name, party, sex)) %>%
  mutate(birth_date = died - days(alive_post + alive_pre)) %>%
  mutate(age = year - year(birth_date))
```

###

The dplyr `case_when()` function can be combined with `mutate()` and `as.factor()` to create a new factor in a tibble. Run the code below to see how we can use `case_when()` to categorize candidates into 3 categories based on their age and incumbency.

```{r governors9-10, exercise = TRUE}
governors %>%
  left_join(governor_incumbents, by = c("year", "state")) %>%
  select(-c(state, first_name, last_name, party, sex)) %>%
  mutate(birth_date = died - days(alive_post + alive_pre)) %>%
  mutate(age = year - year(birth_date)) %>%
  mutate(age_range = age - age %% 5) %>%
  mutate(age_incumbency = as.factor(case_when(age <= 50 ~ "Young candidate",
                                              age > 50 & status == "Challenger" ~ "Old challenger",
                                              age > 50 & status == "Incumbent" ~ "Old incumbent")))
```

###

Use `mutate()` one last time, along with `case_when()`, to create the `adv_status` variable. `adv_status` should be a **factor** with three levels: "Incumbent" if `status` is "Incumbent," "Incumbent challenger" if `status` is "Challenger *and* `no_incumbent` is false, and "Open-field challenger" if `no_incumbent` is true.

```{r governors10, exercise = TRUE, exercise.setup = "governor-incumbents", exercise.lines = 11}
governor_incumbents <- governors %>%
  group_by(year, state) %>%
  summarize(no_incumbent = (n_distinct(status) == 1 & status[1] == "Challenger"))

governors %>%
  left_join(governor_incumbents, by = c("year", "state")) %>%
  select(-c(state, first_name, last_name, party, sex)) %>%
  mutate(birth_date = died - days(alive_post + alive_pre)) %>%
  mutate(age = year - year(birth_date)) %>%
  mutate(age_range = age - age %% 5)
```

```{r governors10-hint-1}
# Remember to use as.factor() before case_when().
```

```{r governors10-hint-2, eval = FALSE}
governors %>%
  left_join(governor_incumbents, by = c("year", "state")) %>%
  select(-c(state, first_name, last_name, party, sex)) %>%
  mutate(birth_date = died - days(alive_post + alive_pre)) %>%
  mutate(age = year - year(birth_date)) %>%
  mutate(age_range = age - age %% 5) %>%
  mutate(adv_status = as.factor(case_when(... ~ "Incumbent",
                                          ... ~ "Incumbent challenger",
                                          ... ~ "Open-field challenger")))
```

###

Great job! Our next step is to calculate the average win margin for each `age_range` and `adv_status`. First, `group_by()` these two variables. Then, use `summarize()` to calculate `mean_win_margin`, the average win margin for each group.

```{r governors11, exercise = TRUE, exercise.setup = "governor-incumbents", exercise.lines = 14}
governor_incumbents <- governors %>%
  group_by(year, state) %>%
  summarize(no_incumbent = (n_distinct(status) == 1 & status[1] == "Challenger"))

governors %>%
  left_join(governor_incumbents, by = c("year", "state")) %>%
  select(-c(state, first_name, last_name, party, sex)) %>%
  mutate(birth_date = died - days(alive_post + alive_pre)) %>%
  mutate(age = year - year(birth_date)) %>%
  mutate(age_range = age - age %% 5) %>%
  mutate(adv_status = as.factor(case_when(status == "Incumbent" ~ "Incumbent",
                                          no_incumbent == FALSE & status == "Challenger" ~ "Incumbent challenger",
                                          no_incumbent == TRUE ~ "Open-field challenger")))
```

```{r governors11-hint, eval = FALSE}
governors %>%
  left_join(governor_incumbents, by = c("year", "state")) %>%
  select(-c(state, first_name, last_name, party, sex)) %>%
  mutate(birth_date = died - days(alive_post + alive_pre)) %>%
  mutate(age = year - year(birth_date)) %>%
  mutate(age_range = age - age %% 5) %>%
  mutate(adv_status = as.factor(case_when(status == "Incumbent" ~ "Incumbent",
                                          no_incumbent == FALSE & status == "Challenger" ~ "Incumbent challenger",
                                          no_incumbent == TRUE ~ "Open-field challenger"))) %>%
  group_by(...) %>%
  summarize(...)
```

###

Add a `ggplot()` call that creates a bar chart with `age_range` on the x-axis and `mean_win_margin` on the y-axis.

```{r governors12, exercise = TRUE, exercise.setup = "governor-incumbents", exercise.lines = 16}
governor_incumbents <- governors %>%
  group_by(year, state) %>%
  summarize(no_incumbent = (n_distinct(status) == 1 & status[1] == "Challenger"))

governors %>%
  left_join(governor_incumbents, by = c("year", "state")) %>%
  select(-c(state, first_name, last_name, party, sex)) %>%
  mutate(birth_date = died - days(alive_post + alive_pre)) %>%
  mutate(age = year - year(birth_date)) %>%
  mutate(age_range = age - age %% 5) %>%
  mutate(adv_status = as.factor(case_when(status == "Incumbent" ~ "Incumbent",
                                          no_incumbent == FALSE & status == "Challenger" ~ "Incumbent challenger",
                                          no_incumbent == TRUE ~ "Open-field challenger"))) %>%
  group_by(age_range, adv_status) %>%
  summarize(mean_win_margin = mean(win_margin))
```

```{r governors12-hint}
# Did you remember to use geom_col() instead of geom_bar()?
```

###

This graph is really messy because each bar represents the `mean_win_margin` for all 3 `adv_status`es. Therefore, use `facet_wrap()` to facet the graph by `adv_status`.

```{r governors13, exercise = TRUE, exercise.setup = "governor-incumbents", exercise.lines = 18}
governor_incumbents <- governors %>%
  group_by(year, state) %>%
  summarize(no_incumbent = (n_distinct(status) == 1 & status[1] == "Challenger"))

governors %>%
  left_join(governor_incumbents, by = c("year", "state")) %>%
  select(-c(state, first_name, last_name, party, sex)) %>%
  mutate(birth_date = died - days(alive_post + alive_pre)) %>%
  mutate(age = year - year(birth_date)) %>%
  mutate(age_range = age - age %% 5) %>%
  mutate(adv_status = as.factor(case_when(status == "Incumbent" ~ "Incumbent",
                                          no_incumbent == FALSE & status == "Challenger" ~ "Incumbent challenger",
                                          no_incumbent == TRUE ~ "Open-field challenger"))) %>%
  group_by(age_range, adv_status) %>%
  summarize(mean_win_margin = mean(win_margin)) %>%
  ggplot(mapping = aes(x = age_range, y = mean_win_margin)) +
    geom_col()
```

```{r governors13-hint, eval = FALSE}
governors %>%
  left_join(governor_incumbents, by = c("year", "state")) %>%
  select(-c(state, first_name, last_name, party, sex)) %>%
  mutate(birth_date = died - days(alive_post + alive_pre)) %>%
  mutate(age = year - year(birth_date)) %>%
  mutate(age_range = age - age %% 5) %>%
  mutate(adv_status = as.factor(case_when(status == "Incumbent" ~ "Incumbent",
                                          no_incumbent == FALSE & status == "Challenger" ~ "Incumbent challenger",
                                          no_incumbent == TRUE ~ "Open-field challenger"))) %>%
  group_by(age_range, adv_status) %>%
  summarize(mean_win_margin = mean(win_margin)) %>%
  ggplot(mapping = aes(x = age_range, y = mean_win_margin)) +
    geom_col() +
    facet_wrap(...)
```

###

The graph is slightly difficult to read because there is no clear trend from left to right. Use an `fct_` function to reorder the three faceted graphs such that the graph with the lowest `mean_win_margin`s is on the left and the graph with the highest `mean_win_margin`s is on the right.

```{r governors14, exercise = TRUE, exercise.setup = "governor-incumbents", exercise.lines = 19}
governor_incumbents <- governors %>%
  group_by(year, state) %>%
  summarize(no_incumbent = (n_distinct(status) == 1 & status[1] == "Challenger"))

governors %>%
  left_join(governor_incumbents, by = c("year", "state")) %>%
  select(-c(state, first_name, last_name, party, sex)) %>%
  mutate(birth_date = died - days(alive_post + alive_pre)) %>%
  mutate(age = year - year(birth_date)) %>%
  mutate(age_range = age - age %% 5) %>%
  mutate(adv_status = as.factor(case_when(status == "Incumbent" ~ "Incumbent",
                                          no_incumbent == FALSE & status == "Challenger" ~ "Incumbent challenger",
                                          no_incumbent == TRUE ~ "Open-field challenger"))) %>%
  group_by(age_range, adv_status) %>%
  summarize(mean_win_margin = mean(win_margin)) %>%
  ggplot(mapping = aes(x = age_range, y = mean_win_margin)) +
    geom_col() +
    facet_wrap(~ adv_status)
```

```{r governors14-hint}
# Try using fct_reorder(...) to replace adv_status inside the facet_wrap() function.
```

###

Amazing work! We can now easily see that incumbents have much higher win margins that open-field challengers, who, in turn, have much higher win margins than incumbent challengers. In addition, younger candidates seem to do better than older candidates on average.

To finish your plot, use `labs()` to rename the x-axis label as "age" and to rename the y-axis label as "win margin." In addition, give the graph a title and subtitle of your choosing.

```{r governors15, exercise = TRUE, exercise.setup = "governor-incumbents", exercise.lines = 19}
governor_incumbents <- governors %>%
  group_by(year, state) %>%
  summarize(no_incumbent = (n_distinct(status) == 1 & status[1] == "Challenger"))

governors %>%
  left_join(governor_incumbents, by = c("year", "state")) %>%
  select(-c(state, first_name, last_name, party, sex)) %>%
  mutate(birth_date = died - days(alive_post + alive_pre)) %>%
  mutate(age = year - year(birth_date)) %>%
  mutate(age_range = age - age %% 5) %>%
  mutate(adv_status = as.factor(case_when(status == "Incumbent" ~ "Incumbent",
                                          no_incumbent == FALSE & status == "Challenger" ~ "Incumbent challenger",
                                          no_incumbent == TRUE ~ "Open-field challenger"))) %>%
  group_by(age_range, adv_status) %>%
  summarize(mean_win_margin = mean(win_margin)) %>%
  ggplot(mapping = aes(x = age_range, y = mean_win_margin)) +
    geom_col() +
    facet_wrap(~ fct_reorder(adv_status, mean_win_margin))
```

```{r governors15-hint, eval = FALSE}
governors %>%
  left_join(governor_incumbents, by = c("year", "state")) %>%
  select(-c(state, first_name, last_name, party, sex)) %>%
  mutate(birth_date = died - days(alive_post + alive_pre)) %>%
  mutate(age = year - year(birth_date)) %>%
  mutate(age_range = age - age %% 5) %>%
  mutate(adv_status = as.factor(case_when(status == "Incumbent" ~ "Incumbent",
                                          no_incumbent == FALSE & status == "Challenger" ~ "Incumbent challenger",
                                          no_incumbent == TRUE ~ "Open-field challenger"))) %>%
  group_by(age_range, adv_status) %>%
  summarize(mean_win_margin = mean(win_margin)) %>%
  ggplot(mapping = aes(x = age_range, y = mean_win_margin)) +
    geom_col() +
    facet_wrap(~ fct_reorder(adv_status, mean_win_margin)) +
    labs(...)
```








## Data Wrangling: nes
###

`nes`, short for "National Election Studies," contains the personal and political information of almost 40,000 American voters, as well as whether or not they voted in that year's presidential election.

Start by running `skim()`, an updated version of `summary()`, on `nes`. See if you can figure out the first and last years in the data set.

```{r nes1, exercise = TRUE}

```

###

Use `levels()` and the `$` operator to return the levels of the `education` variable. What are they?

```{r nes2, exercise = TRUE}

```

```{r nes2-hint}
# The factor that we'd like to investigate is nes$education.
```

###

Start a pipe by selecting the `year`, `education`, `pres_appr`, and `voted` columns in `nes`.

```{r nes3, exercise = TRUE}
nes
```

###

Continue by filtering the tibble such that `education` is either "Some Highschool," "Highschool," "Some College," or "Adv. Degree."

```{r nes4, exercise = TRUE}
nes %>%
  select(c(year, education, pres_appr, voted))
```

```{r nes4-hint}
# Remember to use the %in% operator alongside the c() function.
```

###

After filtering a factor, always remember that the *levels* of the factor have not been removed. To fix this, add a call to the pipe that drops (i.e. permanently removes) all deleted levels.

```{r nes5, exercise = TRUE, exercise.lines = 4}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree"))
```

```{r nes5-hint}
# Use the droplevels() function.
```

###

The dplyr `if_else()` function can be used alongside `mutate()` and `as.factor()` to create a factor with two levels depending on whether a certain `condition` is met. Run the code below to see how we can use `if_else()` to separate the `nes` data set into 2 groups based on whether the value of `ideology` is positive.

```{r nes5-6, exercise = TRUE}
nes %>%
  mutate(pos_ideology = as.factor(if_else(condition = ideology > 0,
                                          true = "ideology_is_positive",
                                          false = "ideology_not_positive")))
```

###

Now, use `if_else()` to `mutate()` a new variable, `opinion`. `opinion` should be a **factor** that equals "has_opinion" if that person either approves *or* disapproves of the president, but "no_opinion" otherwise. To do this, use the `if_else()` function with the condition being detection of the pattern "prove" in the string `pres_appr`.

```{r nes6, exercise = TRUE, exercise.lines = 5}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels()
```

```{r nes6-hint-1}
# Remember to use as.factor() before if_else().
```

```{r nes6-hint-2}
# The function we want to use for the condition is str_detect().
```

```{r nes6-hint-3, eval = FALSE}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(...),
                                     true = ...,
                                     false = ...)))
```

###

Our goal for the next few exercises will be to calculate voter turnout based on their education and whether or not they have an opinion of the president. 

To start, group the tibble by `year`, `voted`, `opinion`, and `education`. Then, use `summarize()` to make a new variable, `count`, that simply counts the number of people (i.e. rows) in each group. What goes wrong?

```{r nes7, exercise = TRUE, exercise.lines = 8}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion")))
```

```{r nes7-hint}
# Remember that the n() function counts the number of rows in each group.
```

###

If we look closely, many of our rows have a value of `NA` for either `voted` or `opinion`! Furthermore, `n()` doesn't have an `na.rm` argument. To remove the `NA`s, use tidyr's `drop_na()` before our `group_by()` call to remove all rows with an `NA` in the `voted` or `opinion` columns.

```{r nes8, exercise = TRUE, exercise.lines = 11, eval = FALSE}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion"))) %>%
  ...
  group_by(year, voted, opinion, education) %>%
  summarize(count = n())
```

```{r nes8-hint, eval = FALSE}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion"))) %>%
  drop_na(...) %>%
  group_by(year, voted, opinion, education) %>%
  summarize(count = n())
```

###

Our goal is to calculate voter turnout, the number of people who voted divided by the total number of people. Therefore, we want `Yes` and `No` (currently in the `voted` column) to be their own columns with the values that are currently in the `count` column.

Use one of the `pivot_` functions to tidy our data in this way.

```{r nes9, exercise = TRUE, exercise.lines = 11}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion"))) %>%
  drop_na(education, opinion) %>%
  group_by(year, voted, opinion, education) %>%
  summarize(count = n())
```

```{r nes9-hint-1}
# Because we're making new columns from values, we want the pivot_wider() function.
```

```{r nes9-hint-2, eval = FALSE}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mmutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion"))) %>%
  drop_na(education, opinion) %>%
  group_by(year, voted, opinion, education) %>%
  summarize(count = n()) %>%
  pivot_wider(names_from = ..., values_from = ...)
```

###

Great job! Now, to calculate turnout, simply `mutate()` another variable, `turnout`, equal to the number of people who voted (the number of `Yes`) divided by the total number of people.

```{r nes10, exercise = TRUE, exercise.lines = 12}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion"))) %>%
  drop_na(education, opinion) %>%
  group_by(year, voted, opinion, education) %>%
  summarize(count = n()) %>%
  pivot_wider(names_from = voted, values_from = count)
```

```{r nes10-hint}
# Remember that the total number of people in each group is (Yes + No).
```

###

Next, add a `ggplot()` call to make a line graph that maps `year` to the x-axis, `turnout` to the y-axis, and `education` to both the color and linetype aesthetics.

```{r nes11, exercise = TRUE, exercise.lines = 13}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion"))) %>%
  drop_na(education, opinion) %>%
  group_by(year, voted, opinion, education) %>%
  summarize(count = n()) %>%
  pivot_wider(names_from = voted, values_from = count) %>%
  mutate(turnout = Yes / (Yes + No))
```

###

Use `facet_wrap` to facet the graph by opinion.

```{r nes12, exercise = TRUE, exercise.lines = 15}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion"))) %>%
  drop_na(education, opinion) %>%
  group_by(year, voted, opinion, education) %>%
  summarize(count = n()) %>%
  pivot_wider(names_from = voted, values_from = count) %>%
  mutate(turnout = Yes / (Yes + No)) %>%
  ggplot(mapping = aes(x = year, y = turnout, color = education, linetype = education)) +
    geom_line()
```

```{r nes12-hint, eval = FALSE}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion"))) %>%
  drop_na(education, opinion) %>%
  group_by(year, voted, opinion, education) %>%
  summarize(count = n()) %>%
  pivot_wider(names_from = voted, values_from = count) %>%
  mutate(turnout = Yes / (Yes + No)) %>%
  ggplot(mapping = aes(x = year, y = turnout, color = education, linetype = education)) +
    geom_line() +
    facet_wrap(...)
```

###

This graph is starting to look pretty good, but the ordering of the legend is a bit confusing. Try using an `fct_` function to reorder the legend (both the color *and* linetype aesthetics) so that Adv. Degree is first, Some College is second, and so on. What goes wrong?

```{r nes13, exercise = TRUE, exercise.lines = 16}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion"))) %>%
  drop_na(education, opinion) %>%
  group_by(year, voted, opinion, education) %>%
  summarize(count = n()) %>%
  pivot_wider(names_from = voted, values_from = count) %>%
  mutate(turnout = Yes / (Yes + No)) %>%
  ggplot(mapping = aes(x = year, y = turnout, color = education, linetype = education)) +
    geom_line() +
    facet_wrap(~ opinion)
```

```{r nes13-hint-1}
# Because this is a line graph, we want to use fct_reorder2().
```

```{r nes13-hint-2, eval = FALSE}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion"))) %>%
  drop_na(education, opinion) %>%
  group_by(year, voted, opinion, education) %>%
  summarize(count = n()) %>%
  pivot_wider(names_from = voted, values_from = count) %>%
  mutate(turnout = Yes / (Yes + No)) %>%
  ggplot(mapping = aes(x = year, y = turnout, color = fct_reorder2(...), linetype = fct_reorder2(...))) +
    geom_line() +
    facet_wrap(~ opinion)
```

###

Although 3 of the 4 `education` statuses are reordered successfully, Adv. Degree is left on the bottom because it doesn't appear in the second graph. To fix this problem, change the `.fun` argument of both `fct_reorder2()` calls to first2 (the default is last2).

```{r nes14, exercise = TRUE, exercise.lines = 16}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion"))) %>%
  drop_na(education, opinion) %>%
  group_by(year, voted, opinion, education) %>%
  summarize(count = n()) %>%
  pivot_wider(names_from = voted, values_from = count) %>%
  mutate(turnout = Yes / (Yes + No)) %>%
  ggplot(mapping = aes(x = year, y = turnout, color = fct_reorder2(education, year, turnout), linetype = fct_reorder2(education, year, turnout))) +
    geom_line() +
    facet_wrap(~ opinion)
```

```{r nes14-hint, eval = FALSE}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion"))) %>%
  drop_na(education, opinion) %>%
  group_by(year, voted, opinion, education) %>%
  summarize(count = n()) %>%
  pivot_wider(names_from = voted, values_from = count) %>%
  mutate(turnout = Yes / (Yes + No)) %>%
  ggplot(mapping = aes(x = year, y = turnout, color = fct_reorder2(education, year, turnout, .fun = ...), linetype = fct_reorder2(education, year, turnout, .fun = ...))) +
    geom_line() +
    facet_wrap(~ opinion)
```

###

Our graph is looking good, but the very long legend title takes up a lot of space. To fix this problem (and to improve the colors of the graph), add a `scale_color_brewer()` function with the "Spectral" palette as well as a `scale_linetype` function. Use **both** scale functions to set the name of the legend to "education."

```{r nes15, exercise = TRUE, exercise.lines = 16}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion"))) %>%
  drop_na(education, opinion) %>%
  group_by(year, voted, opinion, education) %>%
  summarize(count = n()) %>%
  pivot_wider(names_from = voted, values_from = count) %>%
  mutate(turnout = Yes / (Yes + No)) %>%
  ggplot(mapping = aes(x = year, y = turnout, color = fct_reorder2(education, year, turnout, .fun = first2), linetype = fct_reorder2(education, year, turnout, .fun = first2))) +
    geom_line() +
    facet_wrap(~ opinion)
```

```{r nes15-hint-1}
# The scale_color_brewer() function should take 2 arguments, but the scale_linetype() function should only take 1.
```

```{r nes15-hint-2, eval = FALSE}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion"))) %>%
  drop_na(education, opinion) %>%
  group_by(year, voted, opinion, education) %>%
  summarize(count = n()) %>%
  pivot_wider(names_from = voted, values_from = count) %>%
  mutate(turnout = Yes / (Yes + No)) %>%
  ggplot(mapping = aes(x = year, y = turnout, color = fct_reorder2(education, year, turnout, .fun = first2), linetype = fct_reorder2(education, year, turnout, .fun = first2))) +
    geom_line() +
    facet_wrap(~ opinion) +
    scale_color_brewer(..., name = ...) +
    scale_linetype(name = ...)
```

###

Amazing work! From this graph, we see that Americans with a higher level of education tend to vote more often. Furthermore, Americans with an opinion of the president generally have higher voter turnout than Americans without an opinion of the president. Finally, pretty much 100% of Americans with an advanced decree are able to form an opinion of the president (this is why there is no Advanced Degree line in the no_opinion graph: there are too few data points in the table).

To finish your plot, use `labs()` to give the graph a title and subtitle of your choosing.

```{r nes16, exercise = TRUE, exercise.lines = 18}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion"))) %>%
  drop_na(education, opinion) %>%
  group_by(year, voted, opinion, education) %>%
  summarize(count = n()) %>%
  pivot_wider(names_from = voted, values_from = count) %>%
  mutate(turnout = Yes / (Yes + No)) %>%
  ggplot(mapping = aes(x = year, y = turnout, color = fct_reorder2(education, year, turnout, .fun = first2), linetype = fct_reorder2(education, year, turnout, .fun = first2))) +
    geom_line() +
    facet_wrap(~ opinion) +
    scale_color_brewer(palette = "Spectral", name = "education") +
    scale_linetype(name = "education")
```

```{r nes16-hint, eval = FALSE}
nes %>%
  select(c(year, education, pres_appr, voted)) %>%
  filter(education %in% c("Some Highschool", "Highschool", "Some College", "Adv. Degree")) %>%
  droplevels() %>%
  mutate(opinion = as.factor(if_else(condition = str_detect(pres_appr, "prove"),
                                     true = "has_opinion",
                                     false = "no_opinion"))) %>%
  drop_na(education, opinion) %>%
  group_by(year, voted, opinion, education) %>%
  summarize(count = n()) %>%
  pivot_wider(names_from = voted, values_from = count) %>%
  mutate(turnout = Yes / (Yes + No)) %>%
  ggplot(mapping = aes(x = year, y = turnout, color = fct_reorder2(education, year, turnout, .fun = first2), linetype = fct_reorder2(education, year, turnout, .fun = first2))) +
    geom_line() +
    facet_wrap(~ opinion) +
    scale_color_brewer(palette = "Spectral", name = "education") +
    scale_linetype(name = "education") +
    labs(...)
```












## Data Wrangling: nominate
###

The `nominate` data set contains information about every single president and member of Congress since the beginning of the United States.

`glimpse()` the `nominate` data set. What are the variables?

```{r nominate1, exercise = TRUE}

```

###

Our ultimate goal will be to plot the partisan proportion of Congress over time. To do so, however, we first need to calculate the total "population" of each Congressional chamber for each individual session of Congress.

Start by grouping `nominate` by `chamber` and `congress`.

```{r nominate2, exercise = TRUE}
nominate
```

###

Next, use `summarize()` to make a new variable, `total_people`, that is equal to the number of observations (i.e. rows) in each group. Save the entire pipe as `congressional_population`.

```{r nominate3, exercise = TRUE}
nominate %>%
  group_by(chamber, congress)
```

```{r nominate3-hint}
# Remember that n() counts the number of rows in each group.
```

```{r congressional-population}
congressional_population <- nominate %>%
  group_by(chamber, congress) %>%
  summarize(total_people = n())
```

###

Let's return to `nominate`. Start building your pipe by `filter()`ing out (i.e. removing) all of the rows with `chamber` equal to "President."

```{r nominate4, exercise = TRUE, eval = FALSE, exercise.setup = "congressional-population", exercise.lines = 7}
congressional_population <- nominate %>%
  group_by(chamber, congress) %>%
  summarize(total_people = n())

nominate %>%
  ...
```

###

Next, use `select()` to limit the pipe to the columns `congress`, `chamber`, and `party`.

```{r nominate5, exercise = TRUE, exercise.lines = 7, exercise.setup = "congressional-population"}
congressional_population <- nominate %>%
  group_by(chamber, congress) %>%
  summarize(total_people = n())

nominate %>%
  filter(chamber != "President")
```

###

Our next step is to count the number of members of congress by party. First, group the pipe by `chamber`, `congress`, and `party`. Then, use `summarize()` to create the `count_by_party` variable, which is simply a count of the number of observations in each group.

```{r nominate6, exercise = TRUE, exercise.lines = 8, exercise.setup = "congressional-population"}
congressional_population <- nominate %>%
  group_by(chamber, congress) %>%
  summarize(total_people = n())

nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party)
```

```{r nominate6-hint-1}
# Again, the n() function counts the number of rows in each group.
```

```{r nominate6-hint-2, eval = FALSE}
nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(...) %>%
  summarize(...)
```

###

To calculate the *proportion* of Congress held by each party, we need the total population of Congress that we calculated earlier. Use a mutating join to add the `total_people` variable from `congressional_population` to our pipe.

```{r nominate7, exercise = TRUE, exercise.lines = 10, exercise.setup = "congressional-population"}
congressional_population <- nominate %>%
  group_by(chamber, congress) %>%
  summarize(total_people = n())

nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n())
```

```{r nominate7-hint-1}
# The function that you want to use is left_join().
```

```{r nominate7-hint-2, eval = FALSE}
nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(..., by = ...)
```

###

Finally, use `mutate()` to create the variable `party_proportion`, which measures the proportion of Congress held by each party.

```{r nominate8, exercise = TRUE, exercise.lines = 11, exercise.setup = "congressional-population"}
congressional_population <- nominate %>%
  group_by(chamber, congress) %>%
  summarize(total_people = n())

nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress"))
```

```{r nominate8-hint}
# party_proportion should be equal to count_by_party divided by total_people. 
```

###

Great work! Now that we have the proportion of Congress held by each party, we're going to calculate the greatest such proportion for each session of Congress. To do so, first group the pipe by `chamber` and `congress`.

```{r nominate8-9, exercise.lines = 12, exercise = TRUE, exercise.setup = "congressional-population"}
congressional_population <- nominate %>%
  group_by(chamber, congress) %>%
  summarize(total_people = n())

nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people)
```

###

Use `summarize()` and `max()` to create three new variables. `top_party` should be the greatest proportion in each group, `other_parties` should be `1 - top_party`, and `congress_group` should be equal to `congress` rounded down to the nearest multiple of 5, i.e. `congress - congress %% 5` (this will make our graph easier to read at the end).

```{r nominate9, exercise = TRUE, exercise.lines = 13, exercise.setup = "congressional-population"}
congressional_population <- nominate %>%
  group_by(chamber, congress) %>%
  summarize(total_people = n())

nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people) %>%
  group_by(chamber, congress)
```

```{r nominate9-hint-1}
# max(some_variable) returns the greatest value of that variable in each group.
```

```{r nominate9-hint-2, eval = FALSE}
nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people) %>%
  group_by(chamber, congress) %>%
  summarize(top_party = ..., other_parties = ..., congress_group = ...)
```

###

We're going to use `group_by()` and `summarize()` one more time. This time, group by `chamber` and `congress_group`. Then, calculate the variables `mean_top_party` (equal to the average of `top_party` by group), and `mean_other_parties` (equal to `1 - mean_top_party`).

```{r nominate10, exercise = TRUE, exercise.lines = 14, exercise.setup = "congressional-population"}
congressional_population <- nominate %>%
  group_by(chamber, congress) %>%
  summarize(total_people = n())

nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people) %>%
  group_by(chamber, congress) %>%
  summarize(top_party = max(party_proportion), other_parties = 1 - top_party, congress_group = congress - congress %% 5)
```

```{r nominate10-hint, eval = FALSE}
nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people) %>%
  group_by(chamber, congress) %>%
  summarize(top_party = max(party_proportion), other_parties = 1 - top_party, congress_group = congress - congress %% 5) %>%
  group_by(...) %>%
  summarize(mean_top_party = ..., mean_other_parties = ...)
```

###

Our data is no longer in a tidy format. Use a `pivot_` function to make two new columns: `party` (equal to either `mean_top_party` or `mean_other_parties`) and `proportion` (equal to the current value in one of those two columns).

```{r nominate11, exercise = TRUE, exercise.lines = 16, exercise.setup = "congressional-population"}
congressional_population <- nominate %>%
  group_by(chamber, congress) %>%
  summarize(total_people = n())

nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people) %>%
  group_by(chamber, congress) %>%
  summarize(top_party = max(party_proportion), other_parties = 1 - top_party, congress_group = congress - congress %% 5) %>%
  group_by(chamber, congress_group) %>%
  summarize(mean_top_party = mean(top_party), mean_other_parties = 1 - mean_top_party)
```

```{r nominate11-hint-1}
# We're collapsing two column names into one, so use the pivot_longer() function.
```

```{r nominate11-hint-2, eval = FALSE}
nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people) %>%
  group_by(chamber, congress) %>%
  summarize(top_party = max(party_proportion), other_parties = 1 - top_party, congress_group = congress - congress %% 5) %>%
  group_by(chamber, congress_group) %>%
  summarize(mean_top_party = mean(top_party), mean_other_parties = 1 - mean_top_party) %>%
  pivot_longer(cols = ..., names_to = ..., values_to = ...)
```

###

Use `mutate()` and `as.factor()` to convert the `party` variable into a factor.

```{r nominate12, exercise = TRUE, exercise.lines = 17, exercise.setup = "congressional-population"}
congressional_population <- nominate %>%
  group_by(chamber, congress) %>%
  summarize(total_people = n())

nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people) %>%
  group_by(chamber, congress) %>%
  summarize(top_party = max(party_proportion), other_parties = 1 - top_party, congress_group = congress - congress %% 5) %>%
  group_by(chamber, congress_group) %>%
  summarize(mean_top_party = mean(top_party), mean_other_parties = 1 - mean_top_party) %>%
  pivot_longer(cols = c(mean_top_party, mean_other_parties), names_to = "party", values_to = "proportion")
```

```{r nominate12-hint, eval = FALSE}
nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people) %>%
  group_by(chamber, congress) %>%
  summarize(top_party = max(party_proportion), other_parties = 1 - top_party, congress_group = congress - congress %% 5) %>%
  group_by(chamber, congress_group) %>%
  summarize(mean_top_party = mean(top_party), mean_other_parties = 1 - mean_top_party) %>%
  pivot_longer(cols = c(mean_top_party, mean_other_parties), names_to = "party", values_to = "proportion") %>%
  mutate(party = ...)
```

###

Use `ggplot()` to make a line graph with `congress_group` on the x-axis, `proportion` on the y-axis, and `party` mapped to both the color and linetype aesthetics.

```{r nominate13, exercise = TRUE, exercise.lines = 18, exercise.setup = "congressional-population"}
congressional_population <- nominate %>%
  group_by(chamber, congress) %>%
  summarize(total_people = n())

nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people) %>%
  group_by(chamber, congress) %>%
  summarize(top_party = max(party_proportion), other_parties = 1 - top_party, congress_group = congress - congress %% 5) %>%
  group_by(chamber, congress_group) %>%
  summarize(mean_top_party = mean(top_party), mean_other_parties = 1 - mean_top_party) %>%
  pivot_longer(cols = c(mean_top_party, mean_other_parties), names_to = "party", values_to = "proportion") %>%
  mutate(party = as.factor(party))
```

###

Use `facet_wrap()` to facet our line graph by chamber.

```{r nominate14, exercise = TRUE, exercise.lines = 20, exercise.setup = "congressional-population"}
congressional_population <- nominate %>%
  group_by(chamber, congress) %>%
  summarize(total_people = n())

nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people) %>%
  group_by(chamber, congress) %>%
  summarize(top_party = max(party_proportion), other_parties = 1 - top_party, congress_group = congress - congress %% 5) %>%
  group_by(chamber, congress_group) %>%
  summarize(mean_top_party = mean(top_party), mean_other_parties = 1 - mean_top_party) %>%
  pivot_longer(cols = c(mean_top_party, mean_other_parties), names_to = "party", values_to = "proportion") %>%
  mutate(party = as.factor(party)) %>%
  ggplot(mapping = aes(x = congress_group, y = proportion, color = party, linetype = party)) +
  geom_line()
```

###

It's very confusing that `mean_other_parties` is above `mean_top_party` in the legend but below `mean_top_party` on the graph. Use one of the `fct_` functions to reorder the `party` variable (in both the color *and* linetype aesthetics) by `congress_group` and `proportion`.

```{r nominate15, exercise = TRUE, exercise.lines = 21, exercise.setup = "congressional-population"}
congressional_population <- nominate %>%
  group_by(chamber, congress) %>%
  summarize(total_people = n())

nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people) %>%
  group_by(chamber, congress) %>%
  summarize(top_party = max(party_proportion), other_parties = 1 - top_party, congress_group = congress - congress %% 5) %>%
  group_by(chamber, congress_group) %>%
  summarize(mean_top_party = mean(top_party), mean_other_parties = 1 - mean_top_party) %>%
  pivot_longer(cols = c(mean_top_party, mean_other_parties), names_to = "party", values_to = "proportion") %>%
  mutate(party = as.factor(party)) %>%
  ggplot(mapping = aes(x = congress_group, y = proportion, color = party, linetype = party)) +
  geom_line() +
  facet_wrap(~ chamber)
```

```{r nominate15-hint-1}
# Because this is a line graph, use the fct_reorder2() function.
```

```{r nominate15-hint-2, eval = FALSE}
nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people) %>%
  group_by(chamber, congress) %>%
  summarize(top_party = max(party_proportion), other_parties = 1 - top_party, congress_group = congress - congress %% 5) %>%
  group_by(chamber, congress_group) %>%
  summarize(mean_top_party = mean(top_party), mean_other_parties = 1 - mean_top_party) %>%
  pivot_longer(cols = c(mean_top_party, mean_other_parties), names_to = "party", values_to = "proportion") %>%
  mutate(party = as.factor(party)) %>%
  ggplot(mapping = aes(x = congress_group, y = proportion, color = fct_reorder2(...), linetype = fct_reorder2(...))) +
  geom_line() +
  facet_wrap(~ chamber)
```

###

Finally, add two scale functions (`scale_color_discrete()` and `scale_linetype()`) to change the `name` of the legend to "party" and the `labels` of the legend to the vector `("largest party", "all other parties")`.

```{r nominate16, exercise = TRUE, exercise.lines = 21, exercise.setup = "congressional-population"}
congressional_population <- nominate %>%
  group_by(chamber, congress) %>%
  summarize(total_people = n())

nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people) %>%
  group_by(chamber, congress) %>%
  summarize(top_party = max(party_proportion), other_parties = 1 - top_party, congress_group = congress - congress %% 5) %>%
  group_by(chamber, congress_group) %>%
  summarize(mean_top_party = mean(top_party), mean_other_parties = 1 - mean_top_party) %>%
  pivot_longer(cols = c(mean_top_party, mean_other_parties), names_to = "party", values_to = "proportion") %>%
  mutate(party = as.factor(party)) %>%
  ggplot(mapping = aes(x = congress_group, y = proportion, color = fct_reorder2(party, congress_group, proportion), linetype = fct_reorder2(party, congress_group, proportion))) +
  geom_line() +
  facet_wrap(~ chamber)
```

```{r nominate16-hint, eval = FALSE}
nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people) %>%
  group_by(chamber, congress) %>%
  summarize(top_party = max(party_proportion), other_parties = 1 - top_party, congress_group = congress - congress %% 5) %>%
  group_by(chamber, congress_group) %>%
  summarize(mean_top_party = mean(top_party), mean_other_parties = 1 - mean_top_party) %>%
  pivot_longer(cols = c(mean_top_party, mean_other_parties), names_to = "party", values_to = "proportion") %>%
  mutate(party = as.factor(party)) %>%
  ggplot(mapping = aes(x = congress_group, y = proportion, color = fct_reorder2(party, congress_group, proportion), linetype = fct_reorder2(party, congress_group, proportion))) +
  geom_line() +
  facet_wrap(~ chamber) +
  scale_color_discrete(...) +
  scale_linetype(...)
```

###

Fantastic job! The first thing to note is that the largest party always has a proportion greater than 0.5, which (unsurprisingly) implies that third-party candidates are practically nonexistent in the US political system. Next, the Senate has substantially more volatility than the House in the proportion of the chamber controlled by the largest party (can you think of a reason why?). Finally, the trend in both chambers seems to be towards a Congress with a more even distribution of representatives from the two major parties.

To finish your plot, use `labs()` to give the graph a title and subtitle of your choice.

```{r nominate17, exercise = TRUE, exercise.lines = 23, exercise.setup = "congressional-population"}
congressional_population <- nominate %>%
  group_by(chamber, congress) %>%
  summarize(total_people = n())

nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people) %>%
  group_by(chamber, congress) %>%
  summarize(top_party = max(party_proportion), other_parties = 1 - top_party, congress_group = congress - congress %% 5) %>%
  group_by(chamber, congress_group) %>%
  summarize(mean_top_party = mean(top_party), mean_other_parties = 1 - mean_top_party) %>%
  pivot_longer(cols = c(mean_top_party, mean_other_parties), names_to = "party", values_to = "proportion") %>%
  mutate(party = as.factor(party)) %>%
  ggplot(mapping = aes(x = congress_group, y = proportion, color = fct_reorder2(party, congress_group, proportion), linetype = fct_reorder2(party, congress_group, proportion))) +
  geom_line() +
  facet_wrap(~ chamber) +
  scale_color_discrete(name = "party", labels = c("largest party", "all other parties")) +
  scale_linetype(name = "party", labels = c("largest party", "all other parties"))
```

```{r nominate17-hint, eval = FALSE}
nominate %>%
  filter(chamber != "President") %>%
  select(congress, chamber, party) %>%
  group_by(chamber, congress, party) %>%
  summarize(count_by_party = n()) %>%
  left_join(congressional_population, by = c("chamber", "congress")) %>%
  mutate(party_proportion = count_by_party / total_people) %>%
  group_by(chamber, congress) %>%
  summarize(top_party = max(party_proportion), other_parties = 1 - top_party, congress_group = congress - congress %% 5) %>%
  group_by(chamber, congress_group) %>%
  summarize(mean_top_party = mean(top_party), mean_other_parties = 1 - mean_top_party) %>%
  pivot_longer(cols = c(mean_top_party, mean_other_parties), names_to = "party", values_to = "proportion") %>%
  mutate(party = as.factor(party)) %>%
  ggplot(mapping = aes(x = congress_group, y = proportion, color = fct_reorder2(party, congress_group, proportion), linetype = fct_reorder2(party, congress_group, proportion))) +
  geom_line() +
  facet_wrap(~ chamber) +
  scale_color_discrete(name = "party", labels = c("largest party", "all other parties")) +
  scale_linetype(name = "party", labels = c("largest party", "all other parties")) +
  labs(...)
```

## Submit

```{r context="setup"}
submission_ui
```

```{r context="server"}
submission_server()
```

